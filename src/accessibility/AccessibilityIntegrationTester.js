/**
 * AccessibilityIntegrationTester - アクセシビリティシステム統合テスト\n * E2Eテスト・クロスブラウザ・クロスプラットフォーム・回帰テスト自動化\n */\n\nimport { getErrorHandler } from '../utils/ErrorHandler.js';\n\nexport class AccessibilityIntegrationTester {\n    constructor(accessibilityManager) {\n        this.accessibilityManager = accessibilityManager;\n        this.gameEngine = accessibilityManager?.gameEngine;\n        \n        // テスト設定\n        this.config = {\n            enabled: true,\n            autoRun: false,\n            runOnStartup: true,\n            crossBrowserTest: true,\n            performanceTest: true,\n            regressionTest: true,\n            userScenarioTest: true,\n            timeout: 30000,\n            maxRetries: 3\n        };\n        \n        // テストスイート\n        this.testSuites = {\n            // コア機能テスト\n            core: {\n                name: 'Core Accessibility Features',\n                tests: [\n                    'accessibilityManagerInitialization',\n                    'keyboardNavigationBasics',\n                    'screenReaderSupport',\n                    'focusManagement',\n                    'ariaAttributeValidation'\n                ]\n            },\n            \n            // 視覚的アクセシビリティテスト\n            visual: {\n                name: 'Visual Accessibility',\n                tests: [\n                    'colorContrastCompliance',\n                    'textScalingFunctionality',\n                    'colorBlindnessSupport',\n                    'motionReductionSettings',\n                    'highContrastMode'\n                ]\n            },\n            \n            // 音声アクセシビリティテスト\n            audio: {\n                name: 'Audio Accessibility',\n                tests: [\n                    'captionSystemFunctionality',\n                    'soundVisualizationFeatures',\n                    'vibrationFeedbackSystem',\n                    'audioDescriptionSupport'\n                ]\n            },\n            \n            // 運動機能アクセシビリティテスト\n            motor: {\n                name: 'Motor Accessibility',\n                tests: [\n                    'alternativeInputMethods',\n                    'gestureCustomization',\n                    'timingAdjustments',\n                    'oneHandedModeSupport'\n                ]\n            },\n            \n            // 認知支援テスト\n            cognitive: {\n                name: 'Cognitive Support',\n                tests: [\n                    'uiSimplificationFeatures',\n                    'contextualHelpSystem',\n                    'errorRecoveryMechanisms',\n                    'memoryAidsFeatures'\n                ]\n            },\n            \n            // 統合シナリオテスト\n            integration: {\n                name: 'Integration Scenarios',\n                tests: [\n                    'fullGameplayWithAccessibility',\n                    'profileSwitchingScenarios',\n                    'multiLanguageSupport',\n                    'crossFeatureInteraction'\n                ]\n            }\n        };\n        \n        // テスト結果\n        this.testResults = {\n            startTime: null,\n            endTime: null,\n            duration: 0,\n            totalTests: 0,\n            passedTests: 0,\n            failedTests: 0,\n            skippedTests: 0,\n            suiteResults: new Map(),\n            detailResults: [],\n            performanceMetrics: {},\n            issues: []\n        };\n        \n        // ブラウザ・プラットフォーム情報\n        this.environmentInfo = {\n            userAgent: navigator.userAgent,\n            platform: navigator.platform,\n            language: navigator.language,\n            languages: navigator.languages,\n            cookieEnabled: navigator.cookieEnabled,\n            onLine: navigator.onLine,\n            screen: {\n                width: screen.width,\n                height: screen.height,\n                colorDepth: screen.colorDepth\n            },\n            viewport: {\n                width: window.innerWidth,\n                height: window.innerHeight\n            },\n            features: this.detectBrowserFeatures()\n        };\n        \n        // パフォーマンス監視\n        this.performanceMonitor = {\n            startTime: null,\n            marks: new Map(),\n            measures: new Map()\n        };\n        \n        console.log('AccessibilityIntegrationTester initialized');\n    }\n    \n    /**\n     * ブラウザ機能の検出\n     */\n    detectBrowserFeatures() {\n        return {\n            speechSynthesis: 'speechSynthesis' in window,\n            speechRecognition: 'webkitSpeechRecognition' in window || 'SpeechRecognition' in window,\n            vibration: 'vibrate' in navigator,\n            gamepad: 'getGamepads' in navigator,\n            touchscreen: 'ontouchstart' in window,\n            mediaQuery: 'matchMedia' in window,\n            intersectionObserver: 'IntersectionObserver' in window,\n            mutationObserver: 'MutationObserver' in window,\n            localStorage: 'localStorage' in window,\n            sessionStorage: 'sessionStorage' in window,\n            webAudio: 'AudioContext' in window || 'webkitAudioContext' in window\n        };\n    }\n    \n    /**\n     * 全テストスイートの実行\n     */\n    async runAllTests() {\n        console.log('Starting comprehensive accessibility integration tests...');\n        \n        this.testResults.startTime = Date.now();\n        this.performanceMonitor.startTime = performance.now();\n        \n        try {\n            // 各テストスイートを実行\n            for (const [suiteKey, suite] of Object.entries(this.testSuites)) {\n                await this.runTestSuite(suiteKey, suite);\n            }\n            \n            // パフォーマンステストの実行\n            if (this.config.performanceTest) {\n                await this.runPerformanceTests();\n            }\n            \n            // 回帰テストの実行\n            if (this.config.regressionTest) {\n                await this.runRegressionTests();\n            }\n            \n        } catch (error) {\n            console.error('Test execution failed:', error);\n            this.testResults.issues.push({\n                type: 'execution_error',\n                message: error.message,\n                stack: error.stack\n            });\n        } finally {\n            this.finalizeTestResults();\n        }\n        \n        return this.testResults;\n    }\n    \n    /**\n     * テストスイートの実行\n     */\n    async runTestSuite(suiteKey, suite) {\n        console.log(`Running test suite: ${suite.name}`);\n        \n        const suiteStartTime = performance.now();\n        const suiteResults = {\n            name: suite.name,\n            passed: 0,\n            failed: 0,\n            skipped: 0,\n            tests: [],\n            duration: 0\n        };\n        \n        for (const testName of suite.tests) {\n            const testResult = await this.runIndividualTest(suiteKey, testName);\n            \n            suiteResults.tests.push(testResult);\n            this.testResults.detailResults.push(testResult);\n            \n            if (testResult.status === 'passed') {\n                suiteResults.passed++;\n                this.testResults.passedTests++;\n            } else if (testResult.status === 'failed') {\n                suiteResults.failed++;\n                this.testResults.failedTests++;\n            } else {\n                suiteResults.skipped++;\n                this.testResults.skippedTests++;\n            }\n            \n            this.testResults.totalTests++;\n        }\n        \n        suiteResults.duration = performance.now() - suiteStartTime;\n        this.testResults.suiteResults.set(suiteKey, suiteResults);\n        \n        console.log(`Test suite ${suite.name} completed: ${suiteResults.passed}/${suite.tests.length} passed`);\n    }\n    \n    /**\n     * 個別テストの実行\n     */\n    async runIndividualTest(suite, testName) {\n        const testStartTime = performance.now();\n        \n        const testResult = {\n            suite,\n            name: testName,\n            status: 'skipped',\n            duration: 0,\n            error: null,\n            details: {},\n            timestamp: Date.now()\n        };\n        \n        try {\n            console.log(`  Running test: ${testName}`);\n            \n            // テストメソッドの動的呼び出し\n            const testMethod = this[testName];\n            if (typeof testMethod === 'function') {\n                const result = await testMethod.call(this);\n                testResult.status = result.success ? 'passed' : 'failed';\n                testResult.details = result.details || {};\n                \n                if (!result.success) {\n                    testResult.error = result.error || 'Test failed without specific error';\n                }\n            } else {\n                testResult.status = 'skipped';\n                testResult.error = `Test method ${testName} not found`;\n            }\n            \n        } catch (error) {\n            testResult.status = 'failed';\n            testResult.error = error.message;\n            console.error(`Test ${testName} failed:`, error);\n        }\n        \n        testResult.duration = performance.now() - testStartTime;\n        return testResult;\n    }\n    \n    // 個別テストメソッド実装\n    \n    /**\n     * AccessibilityManager初期化テスト\n     */\n    async accessibilityManagerInitialization() {\n        const details = {\n            managerExists: !!this.accessibilityManager,\n            configLoaded: !!this.accessibilityManager?.config,\n            componentsInitialized: 0\n        };\n        \n        if (!this.accessibilityManager) {\n            return {\n                success: false,\n                error: 'AccessibilityManager not found',\n                details\n            };\n        }\n        \n        // コンポーネント初期化確認\n        const components = [\n            'keyboardAccessibilityManager',\n            'screenReaderSupport',\n            'visualAccessibilityManager'\n        ];\n        \n        for (const component of components) {\n            if (this.accessibilityManager[component]) {\n                details.componentsInitialized++;\n            }\n        }\n        \n        return {\n            success: details.componentsInitialized >= 2,\n            details\n        };\n    }\n    \n    /**\n     * キーボードナビゲーション基本テスト\n     */\n    async keyboardNavigationBasics() {\n        const details = {\n            focusableElements: 0,\n            tabOrderCorrect: false,\n            keyboardTrapsDetected: 0\n        };\n        \n        // フォーカス可能要素の検出\n        const focusableElements = document.querySelectorAll(\n            'button:not([disabled]), [href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), [tabindex]:not([tabindex=\"-1\"])'\n        );\n        details.focusableElements = focusableElements.length;\n        \n        // タブオーダーの確認\n        if (focusableElements.length > 0) {\n            details.tabOrderCorrect = this.validateTabOrder(focusableElements);\n        }\n        \n        // キーボードトラップの検出\n        details.keyboardTrapsDetected = this.detectKeyboardTraps();\n        \n        return {\n            success: details.focusableElements > 0 && details.tabOrderCorrect && details.keyboardTrapsDetected === 0,\n            details\n        };\n    }\n    \n    /**\n     * スクリーンリーダーサポートテスト\n     */\n    async screenReaderSupport() {\n        const details = {\n            ariaLabels: 0,\n            ariaRoles: 0,\n            liveRegions: 0,\n            headingStructure: false\n        };\n        \n        // ARIA属性の確認\n        details.ariaLabels = document.querySelectorAll('[aria-label], [aria-labelledby]').length;\n        details.ariaRoles = document.querySelectorAll('[role]').length;\n        details.liveRegions = document.querySelectorAll('[aria-live]').length;\n        \n        // 見出し構造の確認\n        details.headingStructure = this.validateHeadingStructure();\n        \n        return {\n            success: details.ariaLabels > 0 && details.ariaRoles > 0,\n            details\n        };\n    }\n    \n    /**\n     * 色コントラスト準拠テスト\n     */\n    async colorContrastCompliance() {\n        const details = {\n            elementsChecked: 0,\n            compliantElements: 0,\n            nonCompliantElements: [],\n            averageContrast: 0\n        };\n        \n        const textElements = document.querySelectorAll('p, span, div, button, a, label, h1, h2, h3, h4, h5, h6');\n        const contrastRatios = [];\n        \n        for (const element of textElements) {\n            if (element.textContent.trim()) {\n                const contrast = this.calculateContrastRatio(element);\n                if (contrast !== null) {\n                    details.elementsChecked++;\n                    contrastRatios.push(contrast);\n                    \n                    if (contrast >= 4.5) { // WCAG AA標準\n                        details.compliantElements++;\n                    } else {\n                        details.nonCompliantElements.push({\n                            element: element.tagName,\n                            contrast: contrast.toFixed(2)\n                        });\n                    }\n                }\n            }\n        }\n        \n        details.averageContrast = contrastRatios.length > 0 ? \n            contrastRatios.reduce((a, b) => a + b, 0) / contrastRatios.length : 0;\n        \n        const complianceRate = details.elementsChecked > 0 ? \n            details.compliantElements / details.elementsChecked : 0;\n        \n        return {\n            success: complianceRate >= 0.9, // 90%以上の要素が準拠\n            details\n        };\n    }\n    \n    /**\n     * 運動機能アクセシビリティテスト\n     */\n    async alternativeInputMethods() {\n        const details = {\n            gamepadSupport: false,\n            touchSupport: false,\n            voiceRecognition: false,\n            customGestures: false\n        };\n        \n        // ゲームパッドサポート確認\n        details.gamepadSupport = 'getGamepads' in navigator;\n        \n        // タッチサポート確認  \n        details.touchSupport = 'ontouchstart' in window;\n        \n        // 音声認識サポート確認\n        details.voiceRecognition = 'webkitSpeechRecognition' in window || 'SpeechRecognition' in window;\n        \n        // カスタムジェスチャーサポート確認\n        details.customGestures = !!this.accessibilityManager?.gestureCustomizer;\n        \n        const supportedMethods = Object.values(details).filter(Boolean).length;\n        \n        return {\n            success: supportedMethods >= 2,\n            details\n        };\n    }\n    \n    /**\n     * パフォーマンステストの実行\n     */\n    async runPerformanceTests() {\n        console.log('Running performance tests...');\n        \n        const performanceResults = {\n            renderingPerformance: await this.testRenderingPerformance(),\n            memoryUsage: await this.testMemoryUsage(),\n            accessibilityOverhead: await this.testAccessibilityOverhead()\n        };\n        \n        this.testResults.performanceMetrics = performanceResults;\n    }\n    \n    /**\n     * レンダリングパフォーマンステスト\n     */\n    async testRenderingPerformance() {\n        const startTime = performance.now();\n        \n        // レンダリング操作をシミュレート\n        for (let i = 0; i < 100; i++) {\n            const div = document.createElement('div');\n            div.textContent = `Test element ${i}`;\n            div.setAttribute('role', 'button');\n            div.setAttribute('aria-label', `Test button ${i}`);\n            document.body.appendChild(div);\n            \n            // 即座に削除\n            document.body.removeChild(div);\n        }\n        \n        const duration = performance.now() - startTime;\n        \n        return {\n            averageTimePerElement: duration / 100,\n            totalTime: duration,\n            acceptable: duration < 1000 // 1秒以内\n        };\n    }\n    \n    /**\n     * メモリ使用量テスト\n     */\n    async testMemoryUsage() {\n        if (!performance.memory) {\n            return { available: false };\n        }\n        \n        const beforeMemory = {\n            used: performance.memory.usedJSHeapSize,\n            total: performance.memory.totalJSHeapSize,\n            limit: performance.memory.jsHeapSizeLimit\n        };\n        \n        // メモリ集約的な操作をシミュレート\n        const testData = [];\n        for (let i = 0; i < 10000; i++) {\n            testData.push({\n                id: i,\n                ariaLabel: `Test element ${i}`,\n                role: 'button',\n                tabIndex: i\n            });\n        }\n        \n        const afterMemory = {\n            used: performance.memory.usedJSHeapSize,\n            total: performance.memory.totalJSHeapSize,\n            limit: performance.memory.jsHeapSizeLimit\n        };\n        \n        // クリーンアップ\n        testData.length = 0;\n        \n        return {\n            available: true,\n            beforeMemory,\n            afterMemory,\n            memoryIncrease: afterMemory.used - beforeMemory.used,\n            acceptable: (afterMemory.used - beforeMemory.used) < 10 * 1024 * 1024 // 10MB未満\n        };\n    }\n    \n    /**\n     * アクセシビリティオーバーヘッドテスト\n     */\n    async testAccessibilityOverhead() {\n        const withoutA11y = await this.measureWithoutAccessibility();\n        const withA11y = await this.measureWithAccessibility();\n        \n        const overhead = withA11y - withoutA11y;\n        const overheadPercentage = (overhead / withoutA11y) * 100;\n        \n        return {\n            withoutAccessibility: withoutA11y,\n            withAccessibility: withA11y,\n            overhead,\n            overheadPercentage,\n            acceptable: overheadPercentage < 20 // 20%未満のオーバーヘッド\n        };\n    }\n    \n    /**\n     * 回帰テストの実行\n     */\n    async runRegressionTests() {\n        console.log('Running regression tests...');\n        \n        // 以前のテスト結果と比較\n        const previousResults = this.loadPreviousTestResults();\n        if (previousResults) {\n            this.compareWithPreviousResults(previousResults);\n        }\n    }\n    \n    // ユーティリティメソッド\n    \n    /**\n     * タブオーダーの検証\n     */\n    validateTabOrder(elements) {\n        let isValid = true;\n        let previousTabIndex = -1;\n        \n        for (const element of elements) {\n            const tabIndex = parseInt(element.tabIndex) || 0;\n            if (tabIndex > 0 && tabIndex < previousTabIndex) {\n                isValid = false;\n                break;\n            }\n            if (tabIndex > 0) {\n                previousTabIndex = tabIndex;\n            }\n        }\n        \n        return isValid;\n    }\n    \n    /**\n     * キーボードトラップの検出\n     */\n    detectKeyboardTraps() {\n        // 簡易的なキーボードトラップ検出\n        const focusTraps = document.querySelectorAll('[data-focus-trap], .modal:not([aria-hidden=\"true\"])');\n        return focusTraps.length;\n    }\n    \n    /**\n     * 見出し構造の検証\n     */\n    validateHeadingStructure() {\n        const headings = document.querySelectorAll('h1, h2, h3, h4, h5, h6');\n        if (headings.length === 0) return false;\n        \n        let previousLevel = 0;\n        for (const heading of headings) {\n            const currentLevel = parseInt(heading.tagName.charAt(1));\n            \n            if (previousLevel === 0) {\n                // 最初の見出し\n                previousLevel = currentLevel;\n            } else if (currentLevel > previousLevel + 1) {\n                // レベルを飛ばしている（例: h1の次がh3）\n                return false;\n            } else {\n                previousLevel = currentLevel;\n            }\n        }\n        \n        return true;\n    }\n    \n    /**\n     * コントラスト比の計算\n     */\n    calculateContrastRatio(element) {\n        try {\n            const style = window.getComputedStyle(element);\n            const color = style.color;\n            const backgroundColor = style.backgroundColor;\n            \n            if (!color || !backgroundColor) return null;\n            \n            const textRgb = this.parseColor(color);\n            const bgRgb = this.parseColor(backgroundColor);\n            \n            if (!textRgb || !bgRgb) return null;\n            \n            const textLum = this.getLuminance(textRgb);\n            const bgLum = this.getLuminance(bgRgb);\n            \n            const lighter = Math.max(textLum, bgLum);\n            const darker = Math.min(textLum, bgLum);\n            \n            return (lighter + 0.05) / (darker + 0.05);\n        } catch (error) {\n            return null;\n        }\n    }\n    \n    /**\n     * 色の解析\n     */\n    parseColor(color) {\n        const div = document.createElement('div');\n        div.style.color = color;\n        document.body.appendChild(div);\n        \n        const computedColor = window.getComputedStyle(div).color;\n        document.body.removeChild(div);\n        \n        const match = computedColor.match(/rgb\\((\\d+), (\\d+), (\\d+)\\)/);\n        if (match) {\n            return {\n                r: parseInt(match[1]),\n                g: parseInt(match[2]),\n                b: parseInt(match[3])\n            };\n        }\n        \n        return null;\n    }\n    \n    /**\n     * 輝度の計算\n     */\n    getLuminance({ r, g, b }) {\n        const [rs, gs, bs] = [r, g, b].map(c => {\n            c = c / 255;\n            return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);\n        });\n        \n        return 0.2126 * rs + 0.7152 * gs + 0.0722 * bs;\n    }\n    \n    /**\n     * アクセシビリティなしでの測定\n     */\n    async measureWithoutAccessibility() {\n        const startTime = performance.now();\n        \n        // 基本的なDOM操作\n        for (let i = 0; i < 1000; i++) {\n            const div = document.createElement('div');\n            div.textContent = `Element ${i}`;\n            document.body.appendChild(div);\n            document.body.removeChild(div);\n        }\n        \n        return performance.now() - startTime;\n    }\n    \n    /**\n     * アクセシビリティありでの測定\n     */\n    async measureWithAccessibility() {\n        const startTime = performance.now();\n        \n        // アクセシビリティ属性付きのDOM操作\n        for (let i = 0; i < 1000; i++) {\n            const div = document.createElement('div');\n            div.textContent = `Element ${i}`;\n            div.setAttribute('role', 'button');\n            div.setAttribute('aria-label', `Button ${i}`);\n            div.setAttribute('tabindex', '0');\n            document.body.appendChild(div);\n            document.body.removeChild(div);\n        }\n        \n        return performance.now() - startTime;\n    }\n    \n    /**\n     * テスト結果の確定\n     */\n    finalizeTestResults() {\n        this.testResults.endTime = Date.now();\n        this.testResults.duration = this.testResults.endTime - this.testResults.startTime;\n        \n        // 成功率の計算\n        this.testResults.successRate = this.testResults.totalTests > 0 ?\n            (this.testResults.passedTests / this.testResults.totalTests) * 100 : 0;\n        \n        console.log(`\\nAccessibility Integration Tests Completed:`);\n        console.log(`Total Tests: ${this.testResults.totalTests}`);\n        console.log(`Passed: ${this.testResults.passedTests}`);\n        console.log(`Failed: ${this.testResults.failedTests}`);\n        console.log(`Skipped: ${this.testResults.skippedTests}`);\n        console.log(`Success Rate: ${this.testResults.successRate.toFixed(1)}%`);\n        console.log(`Duration: ${this.testResults.duration}ms`);\n    }\n    \n    /**\n     * 以前のテスト結果の読み込み\n     */\n    loadPreviousTestResults() {\n        try {\n            const saved = localStorage.getItem('accessibilityTestResults');\n            return saved ? JSON.parse(saved) : null;\n        } catch (error) {\n            console.warn('Failed to load previous test results:', error);\n            return null;\n        }\n    }\n    \n    /**\n     * テスト結果の保存\n     */\n    saveTestResults() {\n        try {\n            localStorage.setItem('accessibilityTestResults', JSON.stringify({\n                timestamp: this.testResults.endTime,\n                successRate: this.testResults.successRate,\n                totalTests: this.testResults.totalTests,\n                passedTests: this.testResults.passedTests,\n                performanceMetrics: this.testResults.performanceMetrics\n            }));\n        } catch (error) {\n            console.warn('Failed to save test results:', error);\n        }\n    }\n    \n    /**\n     * 以前の結果との比較\n     */\n    compareWithPreviousResults(previousResults) {\n        const comparison = {\n            successRateChange: this.testResults.successRate - previousResults.successRate,\n            testCountChange: this.testResults.totalTests - previousResults.totalTests,\n            regressionDetected: this.testResults.successRate < previousResults.successRate - 5 // 5%以上の低下\n        };\n        \n        this.testResults.regression = comparison;\n        \n        if (comparison.regressionDetected) {\n            console.warn('⚠️ Regression detected! Success rate decreased significantly.');\n        }\n    }\n    \n    /**\n     * テストレポートの生成\n     */\n    generateTestReport() {\n        const report = {\n            summary: {\n                timestamp: new Date(this.testResults.endTime).toISOString(),\n                environment: this.environmentInfo,\n                totalTests: this.testResults.totalTests,\n                passedTests: this.testResults.passedTests,\n                failedTests: this.testResults.failedTests,\n                successRate: this.testResults.successRate,\n                duration: this.testResults.duration\n            },\n            suiteResults: Object.fromEntries(this.testResults.suiteResults),\n            detailResults: this.testResults.detailResults,\n            performanceMetrics: this.testResults.performanceMetrics,\n            issues: this.testResults.issues,\n            recommendations: this.generateRecommendations()\n        };\n        \n        return report;\n    }\n    \n    /**\n     * 改善推奨事項の生成\n     */\n    generateRecommendations() {\n        const recommendations = [];\n        \n        if (this.testResults.successRate < 90) {\n            recommendations.push({\n                priority: 'high',\n                category: 'compliance',\n                message: 'Overall success rate is below 90%. Review failed tests and address issues.'\n            });\n        }\n        \n        if (this.testResults.performanceMetrics?.accessibilityOverhead?.overheadPercentage > 20) {\n            recommendations.push({\n                priority: 'medium',\n                category: 'performance',\n                message: 'Accessibility overhead exceeds 20%. Consider optimization.'\n            });\n        }\n        \n        return recommendations;\n    }\n    \n    // パブリック API\n    \n    /**\n     * 設定の適用\n     */\n    applyConfig(config) {\n        if (config.integrationTester) {\n            Object.assign(this.config, config.integrationTester);\n        }\n        \n        console.log('AccessibilityIntegrationTester configuration applied');\n    }\n    \n    /**\n     * 有効状態の設定\n     */\n    setEnabled(enabled) {\n        this.config.enabled = enabled;\n        console.log(`AccessibilityIntegrationTester ${enabled ? 'enabled' : 'disabled'}`);\n    }\n    \n    /**\n     * クリーンアップ\n     */\n    destroy() {\n        console.log('Destroying AccessibilityIntegrationTester...');\n        \n        // テスト結果の保存\n        if (this.testResults.endTime) {\n            this.saveTestResults();\n        }\n        \n        console.log('AccessibilityIntegrationTester destroyed');\n    }\n}