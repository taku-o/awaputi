/**
 * AccessibilityErrorHandler - アクセシビリティエラー処理システム
 * 回復戦略・グレースフルデグラデーション・エラーログ・レポーティング
 */

import { getErrorHandler } from '../utils/ErrorHandler.js';

export class AccessibilityErrorHandler {
    constructor(accessibilityManager) {
        this.accessibilityManager = accessibilityManager;
        this.gameEngine = accessibilityManager?.gameEngine;
        
        // エラーハンドリング設定
        this.config = {
            enabled: true,
            gracefulDegradation: true,
            autoRecovery: true,
            errorReporting: true,
            fallbackModes: true,
            debugMode: false,
            maxRetries: 3,
            retryDelay: 1000,
            logLevel: 'warn'
        };
        
        // エラー分類
        this.errorCategories = {
            // 重大なエラー（即座に対処が必要）
            critical: {
                severity: 'critical',
                autoRecover: true,
                fallback: 'basicMode',
                reportImmediately: true
            },
            
            // 機能エラー（特定機能が動作しない）
            functional: {
                severity: 'high',
                autoRecover: true,
                fallback: 'degradedMode',
                reportImmediately: false
            },
            
            // パフォーマンスエラー（動作は継続）
            performance: {
                severity: 'medium',
                autoRecover: false,
                fallback: 'optimizedMode',
                reportImmediately: false
            },
            
            // 警告レベル（ユーザー体験に軽微な影響）
            warning: {
                severity: 'low',
                autoRecover: false,
                fallback: null,
                reportImmediately: false
            }
        };
        
        // エラー統計
        this.errorStats = {\n            totalErrors: 0,\n            errorsByCategory: new Map(),\n            errorsByComponent: new Map(),\n            recoveryAttempts: 0,\n            successfulRecoveries: 0,\n            failedRecoveries: 0,\n            fallbackActivations: 0\n        };\n        \n        // アクティブエラー\n        this.activeErrors = new Map();\n        \n        // 回復戦略\n        this.recoveryStrategies = {\n            // スクリーンリーダー関連エラー\n            screenReader: {\n                retryConnection: () => this.retryScreenReaderConnection(),\n                fallbackToTextOutput: () => this.enableTextOutput(),\n                disableAdvancedFeatures: () => this.disableAdvancedScreenReaderFeatures()\n            },\n            \n            // キーボードナビゲーションエラー\n            keyboard: {\n                resetFocusManagement: () => this.resetFocusManagement(),\n                fallbackToBasicNavigation: () => this.enableBasicNavigation(),\n                restoreTabOrder: () => this.restoreTabOrder()\n            },\n            \n            // 視覚的アクセシビリティエラー\n            visual: {\n                resetContrastSettings: () => this.resetContrastSettings(),\n                fallbackToHighContrast: () => this.enableHighContrastMode(),\n                disableAnimations: () => this.disableAnimations()\n            },\n            \n            // 音声アクセシビリティエラー\n            audio: {\n                fallbackToVisualFeedback: () => this.enableVisualFeedback(),\n                disableAudioFeatures: () => this.disableAudioFeatures(),\n                enableBasicCaptions: () => this.enableBasicCaptions()\n            },\n            \n            // 運動機能アクセシビリティエラー\n            motor: {\n                fallbackToBasicInput: () => this.enableBasicInput(),\n                adjustTimingSettings: () => this.adjustTimingSettings(),\n                simplifyGestures: () => this.simplifyGestures()\n            },\n            \n            // 認知支援エラー\n            cognitive: {\n                enableSimplifiedMode: () => this.enableSimplifiedMode(),\n                increaseHelp: () => this.increaseContextualHelp(),\n                reduceComplexity: () => this.reduceUIComplexity()\n            }\n        };\n        \n        // フォールバックモード\n        this.fallbackModes = {\n            basicMode: {\n                name: 'Basic Accessibility Mode',\n                features: ['keyboardNavigation', 'basicScreenReader', 'highContrast'],\n                disabled: ['animations', 'advancedFeatures', 'complexInteractions']\n            },\n            \n            degradedMode: {\n                name: 'Degraded Accessibility Mode',\n                features: ['essentialFeatures', 'fallbackNavigation'],\n                disabled: ['nonEssentialFeatures', 'performanceIntensive']\n            },\n            \n            optimizedMode: {\n                name: 'Performance Optimized Mode',\n                features: ['coreAccessibility', 'optimizedRendering'],\n                disabled: ['heavyAnimations', 'complexCalculations']\n            }\n        };\n        \n        // エラーログ\n        this.errorLog = [];\n        this.maxLogSize = 1000;\n        \n        console.log('AccessibilityErrorHandler initialized');\n        this.initialize();\n    }\n    \n    /**\n     * 初期化\n     */\n    initialize() {\n        try {\n            this.setupGlobalErrorHandling();\n            this.initializeRecoveryStrategies();\n            this.setupPerformanceMonitoring();\n            \n            console.log('AccessibilityErrorHandler initialized successfully');\n        } catch (error) {\n            console.error('Failed to initialize AccessibilityErrorHandler:', error);\n        }\n    }\n    \n    /**\n     * グローバルエラーハンドリングの設定\n     */\n    setupGlobalErrorHandling() {\n        // 未処理エラーのキャッチ\n        window.addEventListener('error', (event) => {\n            this.handleGlobalError(event.error, 'globalError', {\n                filename: event.filename,\n                lineno: event.lineno,\n                colno: event.colno\n            });\n        });\n        \n        // Promise rejectionのキャッチ\n        window.addEventListener('unhandledrejection', (event) => {\n            this.handleGlobalError(event.reason, 'unhandledPromise', {\n                promise: event.promise\n            });\n        });\n    }\n    \n    /**\n     * グローバルエラーの処理\n     */\n    handleGlobalError(error, type, context) {\n        // アクセシビリティ関連エラーの場合のみ処理\n        if (this.isAccessibilityRelatedError(error, context)) {\n            this.handleAccessibilityError(error, type, context);\n        }\n    }\n    \n    /**\n     * アクセシビリティ関連エラーの判定\n     */\n    isAccessibilityRelatedError(error, context) {\n        const errorMessage = error?.message || error?.toString() || '';\n        const filename = context?.filename || '';\n        \n        // エラーメッセージでの判定\n        const accessibilityKeywords = [\n            'accessibility', 'aria', 'screenreader', 'keyboard', 'focus',\n            'contrast', 'caption', 'speech', 'gesture', 'alternative'\n        ];\n        \n        if (accessibilityKeywords.some(keyword => \n            errorMessage.toLowerCase().includes(keyword))) {\n            return true;\n        }\n        \n        // ファイル名での判定\n        if (filename.includes('accessibility') || \n            filename.includes('a11y')) {\n            return true;\n        }\n        \n        return false;\n    }\n    \n    /**\n     * アクセシビリティエラーの処理\n     */\n    handleAccessibilityError(error, component, context = {}) {\n        const errorInfo = this.categorizeError(error, component, context);\n        \n        // エラー統計の更新\n        this.updateErrorStats(errorInfo);\n        \n        // エラーログ記録\n        this.logError(errorInfo);\n        \n        // 自動回復の試行\n        if (errorInfo.category.autoRecover) {\n            this.attemptRecovery(errorInfo);\n        }\n        \n        // フォールバック適用\n        if (errorInfo.category.fallback) {\n            this.activateFallbackMode(errorInfo.category.fallback, errorInfo);\n        }\n        \n        // 即座にレポート\n        if (errorInfo.category.reportImmediately) {\n            this.reportError(errorInfo);\n        }\n        \n        // ユーザー通知\n        this.notifyUser(errorInfo);\n        \n        return errorInfo;\n    }\n    \n    /**\n     * エラーの分類\n     */\n    categorizeError(error, component, context) {\n        const errorMessage = error?.message || error?.toString() || '';\n        \n        let category = 'warning'; // デフォルト\n        \n        // 重大度の判定\n        if (this.isCriticalError(error, component, context)) {\n            category = 'critical';\n        } else if (this.isFunctionalError(error, component, context)) {\n            category = 'functional';\n        } else if (this.isPerformanceError(error, component, context)) {\n            category = 'performance';\n        }\n        \n        return {\n            id: this.generateErrorId(),\n            timestamp: Date.now(),\n            error,\n            component,\n            context,\n            category: this.errorCategories[category],\n            categoryName: category,\n            message: errorMessage,\n            stack: error?.stack,\n            severity: this.errorCategories[category].severity\n        };\n    }\n    \n    /**\n     * 重大エラーの判定\n     */\n    isCriticalError(error, component, context) {\n        const criticalComponents = [\n            'AccessibilityManager',\n            'KeyboardAccessibilityManager',\n            'ARIAManager'\n        ];\n        \n        return criticalComponents.includes(component) && \n               error?.message?.includes('initialization');\n    }\n    \n    /**\n     * 機能エラーの判定\n     */\n    isFunctionalError(error, component, context) {\n        const functionalErrors = [\n            'focus management failed',\n            'screen reader connection lost',\n            'ARIA update failed',\n            'keyboard navigation broken'\n        ];\n        \n        const errorMessage = error?.message?.toLowerCase() || '';\n        return functionalErrors.some(msg => errorMessage.includes(msg));\n    }\n    \n    /**\n     * パフォーマンスエラーの判定\n     */\n    isPerformanceError(error, component, context) {\n        return error?.message?.includes('performance') ||\n               error?.message?.includes('timeout') ||\n               error?.message?.includes('slow');\n    }\n    \n    /**\n     * 回復の試行\n     */\n    async attemptRecovery(errorInfo) {\n        const component = this.getComponentType(errorInfo.component);\n        const strategies = this.recoveryStrategies[component];\n        \n        if (!strategies) {\n            console.warn(`No recovery strategies for component: ${component}`);\n            return false;\n        }\n        \n        this.errorStats.recoveryAttempts++;\n        \n        let retryCount = 0;\n        while (retryCount < this.config.maxRetries) {\n            try {\n                // 各戦略を順番に試行\n                for (const [strategyName, strategy] of Object.entries(strategies)) {\n                    console.log(`Attempting recovery strategy: ${strategyName}`);\n                    await strategy();\n                    \n                    // 回復検証\n                    if (await this.verifyRecovery(errorInfo)) {\n                        this.errorStats.successfulRecoveries++;\n                        this.activeErrors.delete(errorInfo.id);\n                        \n                        console.log(`Recovery successful with strategy: ${strategyName}`);\n                        return true;\n                    }\n                }\n                \n                retryCount++;\n                if (retryCount < this.config.maxRetries) {\n                    await this.delay(this.config.retryDelay * retryCount);\n                }\n                \n            } catch (recoveryError) {\n                console.warn(`Recovery attempt failed:`, recoveryError);\n                retryCount++;\n            }\n        }\n        \n        this.errorStats.failedRecoveries++;\n        console.error(`Recovery failed after ${this.config.maxRetries} attempts`);\n        return false;\n    }\n    \n    /**\n     * コンポーネントタイプの取得\n     */\n    getComponentType(component) {\n        const componentMap = {\n            'ScreenReaderSupport': 'screenReader',\n            'KeyboardAccessibilityManager': 'keyboard',\n            'ContrastManager': 'visual',\n            'VisualFeedbackManager': 'audio',\n            'AlternativeInputManager': 'motor',\n            'SimplificationManager': 'cognitive'\n        };\n        \n        return componentMap[component] || 'unknown';\n    }\n    \n    /**\n     * 回復検証\n     */\n    async verifyRecovery(errorInfo) {\n        const component = errorInfo.component;\n        \n        // コンポーネント固有の検証\n        switch (this.getComponentType(component)) {\n            case 'screenReader':\n                return this.verifyScreenReaderRecovery();\n            case 'keyboard':\n                return this.verifyKeyboardRecovery();\n            case 'visual':\n                return this.verifyVisualRecovery();\n            default:\n                return this.verifyGenericRecovery(component);\n        }\n    }\n    \n    /**\n     * スクリーンリーダー回復検証\n     */\n    verifyScreenReaderRecovery() {\n        // ARIA属性の正常性確認\n        const ariaElements = document.querySelectorAll('[aria-label], [aria-describedby], [role]');\n        return ariaElements.length > 0;\n    }\n    \n    /**\n     * キーボード回復検証\n     */\n    verifyKeyboardRecovery() {\n        // フォーカス可能要素の確認\n        const focusableElements = document.querySelectorAll(\n            'button, [href], input, select, textarea, [tabindex]:not([tabindex=\"-1\"])'\n        );\n        return focusableElements.length > 0 && \n               document.activeElement !== null;\n    }\n    \n    /**\n     * 視覚回復検証\n     */\n    verifyVisualRecovery() {\n        // コントラスト設定の確認\n        const bodyStyle = window.getComputedStyle(document.body);\n        return bodyStyle.color && bodyStyle.backgroundColor;\n    }\n    \n    /**\n     * 汎用回復検証\n     */\n    verifyGenericRecovery(component) {\n        // 基本的な DOM 要素の存在確認\n        return document.body && document.head;\n    }\n    \n    /**\n     * フォールバックモードの有効化\n     */\n    activateFallbackMode(modeName, errorInfo) {\n        const mode = this.fallbackModes[modeName];\n        if (!mode) {\n            console.warn(`Unknown fallback mode: ${modeName}`);\n            return false;\n        }\n        \n        this.errorStats.fallbackActivations++;\n        \n        console.log(`Activating fallback mode: ${mode.name}`);\n        \n        // 機能の無効化\n        mode.disabled.forEach(feature => {\n            this.disableFeature(feature);\n        });\n        \n        // 必要な機能の有効化\n        mode.features.forEach(feature => {\n            this.enableFeature(feature);\n        });\n        \n        // フォールバック状態の記録\n        this.activeErrors.set(errorInfo.id, {\n            ...errorInfo,\n            fallbackMode: modeName,\n            activatedAt: Date.now()\n        });\n        \n        return true;\n    }\n    \n    /**\n     * 機能の無効化\n     */\n    disableFeature(feature) {\n        switch (feature) {\n            case 'animations':\n                this.disableAnimations();\n                break;\n            case 'advancedFeatures':\n                this.disableAdvancedFeatures();\n                break;\n            default:\n                console.log(`Disabling feature: ${feature}`);\n        }\n    }\n    \n    /**\n     * 機能の有効化\n     */\n    enableFeature(feature) {\n        switch (feature) {\n            case 'keyboardNavigation':\n                this.enableBasicNavigation();\n                break;\n            case 'highContrast':\n                this.enableHighContrastMode();\n                break;\n            default:\n                console.log(`Enabling feature: ${feature}`);\n        }\n    }\n    \n    // 個別の回復戦略実装\n    \n    /**\n     * スクリーンリーダー接続の再試行\n     */\n    async retryScreenReaderConnection() {\n        if (this.accessibilityManager?.screenReaderSupport) {\n            return this.accessibilityManager.screenReaderSupport.reconnect();\n        }\n    }\n    \n    /**\n     * テキスト出力の有効化\n     */\n    enableTextOutput() {\n        // DOM要素にテキスト情報を追加\n        const textOutput = document.createElement('div');\n        textOutput.id = 'accessibility-text-output';\n        textOutput.style.cssText = `\n            position: fixed;\n            top: 0;\n            left: 0;\n            z-index: 9999;\n            background: rgba(0,0,0,0.8);\n            color: white;\n            padding: 10px;\n            max-width: 300px;\n        `;\n        document.body.appendChild(textOutput);\n    }\n    \n    /**\n     * 高度なスクリーンリーダー機能の無効化\n     */\n    disableAdvancedScreenReaderFeatures() {\n        // 複雑なARIA属性を簡素化\n        const complexAriaElements = document.querySelectorAll('[aria-expanded], [aria-controls]');\n        complexAriaElements.forEach(element => {\n            element.removeAttribute('aria-expanded');\n            element.removeAttribute('aria-controls');\n        });\n    }\n    \n    /**\n     * フォーカス管理のリセット\n     */\n    resetFocusManagement() {\n        // フォーカストラップをリセット\n        const focusTraps = document.querySelectorAll('[data-focus-trap]');\n        focusTraps.forEach(trap => {\n            trap.removeAttribute('data-focus-trap');\n        });\n        \n        // 最初のフォーカス可能要素にフォーカス\n        const firstFocusable = document.querySelector(\n            'button:not([disabled]), [href], input:not([disabled]), select:not([disabled]), textarea:not([disabled])'\n        );\n        if (firstFocusable) {\n            firstFocusable.focus();\n        }\n    }\n    \n    /**\n     * 基本ナビゲーションの有効化\n     */\n    enableBasicNavigation() {\n        // 基本的なtabindexを設定\n        const interactiveElements = document.querySelectorAll('button, [href], input, select, textarea');\n        interactiveElements.forEach((element, index) => {\n            if (!element.hasAttribute('tabindex')) {\n                element.tabIndex = 0;\n            }\n        });\n    }\n    \n    /**\n     * タブオーダーの復元\n     */\n    restoreTabOrder() {\n        // 論理的なタブオーダーを再設定\n        const elements = Array.from(document.querySelectorAll('[tabindex]'));\n        elements.sort((a, b) => {\n            const aRect = a.getBoundingClientRect();\n            const bRect = b.getBoundingClientRect();\n            \n            if (Math.abs(aRect.top - bRect.top) < 10) {\n                return aRect.left - bRect.left;\n            }\n            return aRect.top - bRect.top;\n        });\n        \n        elements.forEach((element, index) => {\n            element.tabIndex = index + 1;\n        });\n    }\n    \n    /**\n     * コントラスト設定のリセット\n     */\n    resetContrastSettings() {\n        document.body.style.filter = '';\n        document.documentElement.style.filter = '';\n    }\n    \n    /**\n     * 高コントラストモードの有効化\n     */\n    enableHighContrastMode() {\n        document.documentElement.classList.add('high-contrast');\n        \n        // CSS カスタムプロパティで高コントラスト色を設定\n        document.documentElement.style.setProperty('--text-color', '#000000');\n        document.documentElement.style.setProperty('--background-color', '#ffffff');\n        document.documentElement.style.setProperty('--border-color', '#000000');\n    }\n    \n    /**\n     * アニメーションの無効化\n     */\n    disableAnimations() {\n        const style = document.createElement('style');\n        style.textContent = `\n            *, *::before, *::after {\n                animation-duration: 0.01ms !important;\n                animation-iteration-count: 1 !important;\n                transition-duration: 0.01ms !important;\n            }\n        `;\n        document.head.appendChild(style);\n    }\n    \n    /**\n     * 視覚フィードバックの有効化\n     */\n    enableVisualFeedback() {\n        // 音声イベントを視覚的に表示\n        const visualFeedback = document.createElement('div');\n        visualFeedback.id = 'visual-audio-feedback';\n        visualFeedback.style.cssText = `\n            position: fixed;\n            top: 50%;\n            left: 50%;\n            transform: translate(-50%, -50%);\n            z-index: 10000;\n            pointer-events: none;\n        `;\n        document.body.appendChild(visualFeedback);\n    }\n    \n    /**\n     * エラー統計の更新\n     */\n    updateErrorStats(errorInfo) {\n        this.errorStats.totalErrors++;\n        \n        // カテゴリ別統計\n        const category = errorInfo.categoryName;\n        this.errorStats.errorsByCategory.set(\n            category,\n            (this.errorStats.errorsByCategory.get(category) || 0) + 1\n        );\n        \n        // コンポーネント別統計\n        const component = errorInfo.component;\n        this.errorStats.errorsByComponent.set(\n            component,\n            (this.errorStats.errorsByComponent.get(component) || 0) + 1\n        );\n    }\n    \n    /**\n     * エラーログ記録\n     */\n    logError(errorInfo) {\n        this.errorLog.push(errorInfo);\n        \n        // ログサイズ制限\n        if (this.errorLog.length > this.maxLogSize) {\n            this.errorLog = this.errorLog.slice(-this.maxLogSize / 2);\n        }\n        \n        // コンソール出力\n        if (this.config.logLevel === 'all' || \n            (this.config.logLevel === 'warn' && errorInfo.severity !== 'low')) {\n            console.error(`Accessibility Error [${errorInfo.categoryName}]:`, errorInfo);\n        }\n    }\n    \n    /**\n     * エラーレポート\n     */\n    reportError(errorInfo) {\n        if (!this.config.errorReporting) return;\n        \n        // エラーレポートデータの作成\n        const report = {\n            timestamp: errorInfo.timestamp,\n            severity: errorInfo.severity,\n            component: errorInfo.component,\n            message: errorInfo.message,\n            userAgent: navigator.userAgent,\n            url: window.location.href,\n            gameState: this.gameEngine?.getCurrentState?.() || null\n        };\n        \n        // レポートの送信（実装に応じて）\n        this.sendErrorReport(report);\n    }\n    \n    /**\n     * エラーレポートの送信\n     */\n    async sendErrorReport(report) {\n        try {\n            // ここで実際のレポート送信API を呼び出し\n            console.log('Error report prepared:', report);\n            \n            // 例: fetch('/api/accessibility-errors', { ... })\n        } catch (error) {\n            console.warn('Failed to send error report:', error);\n        }\n    }\n    \n    /**\n     * ユーザー通知\n     */\n    notifyUser(errorInfo) {\n        if (errorInfo.severity === 'critical' || errorInfo.severity === 'high') {\n            this.showErrorNotification(errorInfo);\n        }\n    }\n    \n    /**\n     * エラー通知の表示\n     */\n    showErrorNotification(errorInfo) {\n        const notification = document.createElement('div');\n        notification.className = 'accessibility-error-notification';\n        notification.style.cssText = `\n            position: fixed;\n            top: 20px;\n            right: 20px;\n            background: #f44336;\n            color: white;\n            padding: 1rem;\n            border-radius: 4px;\n            z-index: 10001;\n            max-width: 300px;\n            box-shadow: 0 2px 10px rgba(0,0,0,0.2);\n        `;\n        \n        notification.innerHTML = `\n            <div style=\"display: flex; align-items: center; margin-bottom: 0.5rem;\">\n                <span style=\"font-size: 1.2rem; margin-right: 0.5rem;\">⚠️</span>\n                <strong>アクセシビリティエラー</strong>\n            </div>\n            <p style=\"margin: 0 0 0.5rem 0; font-size: 0.9rem;\">\n                一部の機能が正常に動作しない可能性があります。\n            </p>\n            <button onclick=\"this.parentElement.remove()\" \n                    style=\"background: rgba(255,255,255,0.2); border: none; color: white; padding: 0.3rem 0.8rem; border-radius: 2px; cursor: pointer;\">\n                閉じる\n            </button>\n        `;\n        \n        document.body.appendChild(notification);\n        \n        // 10秒後に自動削除\n        setTimeout(() => {\n            if (notification.parentElement) {\n                notification.parentElement.removeChild(notification);\n            }\n        }, 10000);\n    }\n    \n    /**\n     * ユーティリティメソッド\n     */\n    generateErrorId() {\n        return `error_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    }\n    \n    delay(ms) {\n        return new Promise(resolve => setTimeout(resolve, ms));\n    }\n    \n    // パブリックAPI\n    \n    /**\n     * エラー統計の取得\n     */\n    getErrorStats() {\n        return {\n            ...this.errorStats,\n            errorsByCategory: Object.fromEntries(this.errorStats.errorsByCategory),\n            errorsByComponent: Object.fromEntries(this.errorStats.errorsByComponent),\n            recoveryRate: this.errorStats.recoveryAttempts > 0 ? \n                (this.errorStats.successfulRecoveries / this.errorStats.recoveryAttempts) * 100 : 0\n        };\n    }\n    \n    /**\n     * エラーログの取得\n     */\n    getErrorLog(limit = 50) {\n        return this.errorLog.slice(-limit);\n    }\n    \n    /**\n     * アクティブエラーの取得\n     */\n    getActiveErrors() {\n        return Array.from(this.activeErrors.values());\n    }\n    \n    /**\n     * エラーログのクリア\n     */\n    clearErrorLog() {\n        this.errorLog = [];\n        console.log('Error log cleared');\n    }\n    \n    /**\n     * 設定の適用\n     */\n    applyConfig(config) {\n        if (config.errorHandler) {\n            Object.assign(this.config, config.errorHandler);\n        }\n        \n        console.log('AccessibilityErrorHandler configuration applied');\n    }\n    \n    /**\n     * 有効状態の設定\n     */\n    setEnabled(enabled) {\n        this.config.enabled = enabled;\n        console.log(`AccessibilityErrorHandler ${enabled ? 'enabled' : 'disabled'}`);\n    }\n    \n    /**\n     * クリーンアップ \n     */\n    destroy() {\n        console.log('Destroying AccessibilityErrorHandler...');\n        \n        // アクティブエラーのクリア\n        this.activeErrors.clear();\n        \n        // エラーログのクリア\n        this.errorLog = [];\n        \n        console.log('AccessibilityErrorHandler destroyed');\n    }\n}