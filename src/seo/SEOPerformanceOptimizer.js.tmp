/**
 * SEOパフォーマンス最適化クラス
 * 
 * SEO関連アセットの最適化とパフォーマンス監視機能を提供
 */
import { SEOConfig, getBaseUrl } from './SEOConfig.js';
import { seoLogger } from './SEOLogger.js';
import { seoErrorHandler } from './SEOErrorHandler.js';
import { 
    measurePerformance,
    generateCacheKey 
} from './SEOUtils.js';

export class SEOPerformanceOptimizer {
    constructor() {
        this.baseUrl = getBaseUrl();
        this.imageCache = new Map();
        this.metadataCache = new Map();
        this.compressionCache = new Map();
        this.loadingTasks = new Map();
        
        // パフォーマンス監視
        this.performanceMetrics = {
            imageOptimizations: 0,
            cacheHits: 0,
            cacheMisses: 0,
            averageCompressionRatio: 0,
            totalProcessingTime: 0
        };
        
        // WebP対応の検出
        this.webpSupported = null;
        
        this._initialize();
    }
    
    /**
     * 初期化処理
     * @private
     */
    _initialize() {
        try {
            // WebP対応の検出
            this._detectWebPSupport();
            
            // Service Workerとの連携設定
            this._setupServiceWorkerIntegration();
            
            // パフォーマンス監視の開始
            this._startPerformanceMonitoring();
            
            seoLogger.info('SEOPerformanceOptimizer initialized successfully');
        } catch (error) {
            seoErrorHandler.handle(error, 'seoPerformanceOptimizerInit');
        }
    }
    
    /**
     * 画像の最適化
     * @param {string} imageUrl - 画像URL
     * @param {Object} options - 最適化オプション
     * @returns {Promise<string>}
     */
    async optimizeImage(imageUrl, options = {}) {
        try {
            const {
                width = null,
                height = null,
                quality = 85,
                format = 'auto', // 'auto', 'webp', 'png', 'jpg'
                progressive = true,
                lazy = false
            } = options;
            
            const cacheKey = generateCacheKey('image_optimization', { imageUrl, ...options });
            
            // キャッシュチェック
            if (this.imageCache.has(cacheKey)) {
                this.performanceMetrics.cacheHits++;
                return this.imageCache.get(cacheKey);
            }
            
            this.performanceMetrics.cacheMisses++;
            const startTime = performance.now();
            
            // 最適化形式の決定
            const targetFormat = await this._determineOptimalFormat(format, imageUrl);
            
            // 画像の処理
            let optimizedUrl;
            if (this._isDataUrl(imageUrl)) {
                // Data URLの場合は直接最適化
                optimizedUrl = await this._optimizeDataUrl(imageUrl, {
                    width, height, quality, format: targetFormat, progressive
                });
            } else {
                // 外部URLの場合は最適化パラメータ付きURLを生成
                optimizedUrl = this._generateOptimizedUrl(imageUrl, {
                    width, height, quality, format: targetFormat, progressive
                });
            }
            
            // 遅延読み込み対応
            if (lazy) {
                optimizedUrl = this._addLazyLoadingSupport(optimizedUrl);
            }
            
            // パフォーマンスメトリクスの更新
            const processingTime = performance.now() - startTime;
            this.performanceMetrics.totalProcessingTime += processingTime;
            this.performanceMetrics.imageOptimizations++;
            
            // キャッシュに保存
            this.imageCache.set(cacheKey, optimizedUrl);
            
            return optimizedUrl;
        } catch (error) {
            return seoErrorHandler.handle(error, 'optimizeImage', { imageUrl, options });
        }
    }
    
    /**
     * 構造化データの最適化
     * @param {Object} structuredData - 構造化データ
     * @param {Object} options - 最適化オプション
     * @returns {Promise<Object>}
     */
    async optimizeStructuredData(structuredData, options = {}) {
        try {
            const {
                minify = true,
                removeOptionalFields = false,
                compressImages = true,
                cacheEnabled = true
            } = options;
            
            const cacheKey = generateCacheKey('structured_data', { structuredData, ...options });
            
            if (cacheEnabled && this.metadataCache.has(cacheKey)) {
                return this.metadataCache.get(cacheKey);
            }
            
            let optimized = { ...structuredData };
            
            // 画像URLの最適化
            if (compressImages) {
                optimized = await this._optimizeStructuredDataImages(optimized);
            }
            
            // 不要フィールドの削除
            if (removeOptionalFields) {
                optimized = this._removeOptionalFields(optimized);
            }
            
            // データの圧縮（minify）
            if (minify) {
                optimized = this._minifyStructuredData(optimized);
            }
            
            // キャッシュに保存
            if (cacheEnabled) {
                this.metadataCache.set(cacheKey, optimized);
            }
            
            return optimized;
        } catch (error) {
            return seoErrorHandler.handle(error, 'optimizeStructuredData', { structuredData, options });
        }
    }
    
    /**
     * メタタグのパフォーマンス最適化
     * @param {Object} metaTags - メタタグデータ
     * @param {Object} options - 最適化オプション
     * @returns {Promise<Object>}
     */
    async optimizeMetaTags(metaTags, options = {}) {
        try {
            const {
                compressDescriptions = true,
                optimizeImages = true,
                removeDuplicates = true,
                prioritizeCharset = true
            } = options;
            
            let optimized = { ...metaTags };
            
            // 画像の最適化
            if (optimizeImages && optimized.image) {
                optimized.image = await this.optimizeImage(optimized.image, {
                    width: 1200,
                    height: 630,
                    quality: 85,
                    format: 'auto',
                    progressive: true
                });
            }
            
            // 説明文の最適化
            if (compressDescriptions) {
                optimized = this._optimizeTextContent(optimized);
            }
            
            // 重複の除去
            if (removeDuplicates) {
                optimized = this._removeDuplicateMetaTags(optimized);
            }
            
            // charset優先化
            if (prioritizeCharset) {
                optimized = this._prioritizeCharset(optimized);
            }
            
            return optimized;
        } catch (error) {
            return seoErrorHandler.handle(error, 'optimizeMetaTags', { metaTags, options });
        }
    }
    
    /**
     * キャッシュヘッダーの設定
     * @param {string} assetType - アセットタイプ
     * @returns {Object}
     */
    generateCacheHeaders(assetType) {
        const cacheConfigs = {
            image: {
                'Cache-Control': 'public, max-age=31536000, immutable', // 1年
                'Expires': new Date(Date.now() + 31536000000).toUTCString(),
                'ETag': `"${Date.now()}-${Math.random()}"`,
                'Vary': 'Accept'
            },
            metadata: {
                'Cache-Control': 'public, max-age=3600', // 1時間
                'Expires': new Date(Date.now() + 3600000).toUTCString(),
                'ETag': `"meta-${Date.now()}"`,
                'Content-Type': 'application/json'
            },
            sitemap: {
                'Cache-Control': 'public, max-age=86400', // 24時間
                'Expires': new Date(Date.now() + 86400000).toUTCString(),
                'Content-Type': 'application/xml'
            },
            favicon: {
                'Cache-Control': 'public, max-age=604800', // 1週間
                'Expires': new Date(Date.now() + 604800000).toUTCString(),
                'Content-Type': 'image/x-icon'
            }
        };
        
        return cacheConfigs[assetType] || cacheConfigs.metadata;
    }
    
    /**
     * 遅延読み込みシステムの実装
     * @param {Array} imageUrls - 画像URL配列
     * @param {Object} options - オプション
     * @returns {Promise<void>}
     */
    async implementLazyLoading(imageUrls, options = {}) {
        try {
            const {
                rootMargin = '50px',
                threshold = 0.1,
                priority = 'low'
            } = options;
            
            // Intersection Observer APIの使用
            if (typeof window !== 'undefined' && 'IntersectionObserver' in window) {
                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            const img = entry.target;
                            const src = img.dataset.src;
                            
                            if (src) {
                                img.src = src;
                                img.removeAttribute('data-src');
                                observer.unobserve(img);
                            }
                        }
                    });
                }, {
                    rootMargin,
                    threshold
                });
                
                // 画像要素にObserverを適用
                imageUrls.forEach(url => {
                    const img = document.querySelector(`img[data-src="${url}"]`);
                    if (img) {
                        observer.observe(img);
                    }
                });
            }
            
            seoLogger.info(`Lazy loading implemented for ${imageUrls.length} images`);
        } catch (error) {
            seoErrorHandler.handle(error, 'implementLazyLoading', { imageUrls, options });
        }
    }
    
    /**
     * WebP対応の検出
     * @private
     */
    _detectWebPSupport() {
        if (typeof window === 'undefined') {
            this.webpSupported = false; // サーバーサイドでは無効
            return;
        }
        
        // キャッシュされた結果がある場合
        if (this.webpSupported !== null) {
            return Promise.resolve(this.webpSupported);
        }
        
        return new Promise((resolve) => {
            const webP = new Image();
            webP.onload = webP.onerror = () => {
                this.webpSupported = (webP.height === 2);
                resolve(this.webpSupported);
            };
            webP.src = 'data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA';
        });
    }
    
    /**
     * 最適な画像形式の決定
     * @private
     */
    async _determineOptimalFormat(requestedFormat, imageUrl) {
        if (requestedFormat === 'auto') {
            // WebP対応チェック
            await this._detectWebPSupport();
            
            if (this.webpSupported) {
                return 'webp';
            }
            
            // URL拡張子による判定
            const extension = imageUrl.split('.').pop()?.toLowerCase();
            switch (extension) {
                case 'png':
                    return 'png';
                case 'jpg':
                case 'jpeg':
                    return 'jpg';
                default:
                    return 'jpg'; // デフォルト
            }
        }
        
        return requestedFormat;
    }
    
    /**
     * Data URLの最適化
     * @private
     */
    async _optimizeDataUrl(dataUrl, options) {
        if (typeof window === 'undefined') {
            return dataUrl; // サーバーサイドでは元のURLを返す
        }
        
        try {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const img = new Image();
            
            return new Promise((resolve) => {
                img.onload = () => {
                    // キャンバスサイズの設定
                    const targetWidth = options.width || img.width;
                    const targetHeight = options.height || img.height;
                    
                    canvas.width = targetWidth;
                    canvas.height = targetHeight;
                    
                    // 画像の描画
                    ctx.drawImage(img, 0, 0, targetWidth, targetHeight);
                    
                    // 最適化された形式で出力
                    const format = options.format === 'webp' ? 'image/webp' : 
                                 options.format === 'png' ? 'image/png' : 'image/jpeg';
                    const quality = options.quality / 100;
                    
                    const optimizedDataUrl = canvas.toDataURL(format, quality);
                    resolve(optimizedDataUrl);
                };
                
                img.src = dataUrl;
            });
        } catch (error) {
            seoLogger.error('Data URL optimization failed', error);
            return dataUrl;
        }
    }
    
    /**
     * 最適化URL生成
     * @private
     */
    _generateOptimizedUrl(imageUrl, options) {
        const url = new URL(imageUrl, this.baseUrl);
        
        // クエリパラメータで最適化オプションを追加
        if (options.width) url.searchParams.set('w', options.width);
        if (options.height) url.searchParams.set('h', options.height);
        if (options.quality) url.searchParams.set('q', options.quality);
        if (options.format && options.format !== 'auto') {
            url.searchParams.set('format', options.format);
        }
        if (options.progressive) url.searchParams.set('progressive', 'true');
        
        return url.toString();
    }
    
    /**
     * 遅延読み込み対応の追加
     * @private
     */
    _addLazyLoadingSupport(imageUrl) {
        // Loading='lazy'属性のサポート
        return {
            src: imageUrl,
            loading: 'lazy',
            decoding: 'async'
        };
    }
    
    /**
     * Data URLかどうかの判定
     * @private
     */
    _isDataUrl(url) {
        return url.startsWith('data:');
    }
    
    /**
     * 構造化データ内の画像最適化
     * @private
     */
    async _optimizeStructuredDataImages(data) {
        const optimized = { ...data };
        
        // 再帰的に画像URLを探して最適化
        const optimizeRecursively = async (obj) => {
            for (const key in obj) {
                if (obj.hasOwnProperty(key)) {
                    const value = obj[key];
                    
                    if (typeof value === 'string' && this._isImageUrl(value)) {
                        obj[key] = await this.optimizeImage(value, {
                            width: 1200,
                            height: 630,
                            quality: 85,
                            format: 'auto'
                        });
                    } else if (typeof value === 'object' && value !== null) {
                        await optimizeRecursively(value);
                    }
                }
            }
        };
        
        await optimizeRecursively(optimized);
        return optimized;
    }
    
    /**
     * 画像URLかどうかの判定
     * @private
     */
    _isImageUrl(url) {
        if (typeof url !== 'string') return false;
        
        const imageExtensions = ['.jpg', '.jpeg', '.png', '.webp', '.gif', '.svg'];
        const lowercaseUrl = url.toLowerCase();
        
        return imageExtensions.some(ext => lowercaseUrl.includes(ext)) ||
               url.startsWith('data:image/');
    }
    
    /**
     * 不要フィールドの削除
     * @private
     */
    _removeOptionalFields(data) {
        const optionalFields = [
            'potentialAction',
            'mainEntityOfPage',
            'author',
            'publisher',
            'dateModified'
        ];
        
        const cleaned = { ...data };
        optionalFields.forEach(field => {
            if (field in cleaned && !this._isRequiredField(field)) {
                delete cleaned[field];
            }
        });
        
        return cleaned;
    }
    
    /**
     * 必須フィールドの判定
     * @private
     */
    _isRequiredField(field) {
        const requiredFields = [
            '@context',
            '@type',
            'name',
            'description',
            'url'
        ];
        
        return requiredFields.includes(field);
    }
    
    /**
     * 構造化データの圧縮
     * @private
     */
    _minifyStructuredData(data) {
        // 空の値や不要な空白を削除
        const minify = (obj) => {
            if (Array.isArray(obj)) {
                return obj.map(minify).filter(item => item !== null && item !== undefined);
            }
            
            if (typeof obj === 'object' && obj !== null) {
                const minified = {};
                for (const key in obj) {
                    if (obj.hasOwnProperty(key)) {
                        const value = obj[key];
                        if (value !== null && value !== undefined && value !== '') {
                            minified[key] = minify(value);
                        }
                    }
                }
                return minified;
            }
            
            if (typeof obj === 'string') {
                return obj.trim();
            }
            
            return obj;
        };
        
        return minify(data);
    }
    
    /**
     * テキストコンテンツの最適化
     * @private
     */
    _optimizeTextContent(metaTags) {
        const optimized = { ...metaTags };
        
        // 説明文の最適化
        if (optimized.description) {
            optimized.description = this._compressText(optimized.description, 160);
        }
        
        // タイトルの最適化
        if (optimized.title) {
            optimized.title = this._compressText(optimized.title, 60);
        }
        
        // キーワードの最適化
        if (optimized.keywords) {
            optimized.keywords = this._optimizeKeywords(optimized.keywords);
        }
        
        return optimized;
    }
    
    /**
     * テキスト圧縮
     * @private
     */
    _compressText(text, maxLength) {
        if (text.length <= maxLength) return text;
        
        // 単語境界で切り詰め
        const truncated = text.substring(0, maxLength - 3);
        const lastSpace = truncated.lastIndexOf(' ');
        
        if (lastSpace > maxLength * 0.8) {
            return truncated.substring(0, lastSpace) + '...';
        }
        
        return truncated + '...';
    }
    
    /**
     * キーワードの最適化
     * @private
     */
    _optimizeKeywords(keywords) {
        if (typeof keywords !== 'string') return keywords;
        
        const keywordArray = keywords.split(',').map(k => k.trim());
        const uniqueKeywords = [...new Set(keywordArray)]; // 重複除去
        
        // 長さ制限（通常10個以下が推奨）
        return uniqueKeywords.slice(0, 10).join(',');
    }
    
    /**
     * 重複メタタグの除去
     * @private
     */
    _removeDuplicateMetaTags(metaTags) {
        const seen = new Set();
        const optimized = {};
        
        for (const [key, value] of Object.entries(metaTags)) {
            const valueStr = typeof value === 'object' ? JSON.stringify(value) : String(value);
            const signature = `${key}:${valueStr}`;
            
            if (!seen.has(signature)) {
                seen.add(signature);
                optimized[key] = value;
            }
        }
        
        return optimized;
    }
    
    /**
     * charsetの優先化
     * @private
     */
    _prioritizeCharset(metaTags) {
        const optimized = { ...metaTags };
        
        if (optimized.charset) {
            // charsetを最初に配置
            const { charset, ...rest } = optimized;
            return { charset, ...rest };
        }
        
        return optimized;
    }
    
    /**
     * Service Workerとの連携設定
     * @private
     */
    _setupServiceWorkerIntegration() {
        if (typeof navigator === 'undefined' || !('serviceWorker' in navigator)) {
            return;
        }
        
        // Service Workerからのメッセージを監視
        navigator.serviceWorker.addEventListener('message', (event) => {
            const { type, data } = event.data;
            
            switch (type) {
                case 'IMAGE_OPTIMIZED':
                    this._handleImageOptimizationResult(data);
                    break;
                case 'CACHE_UPDATED':
                    this._handleCacheUpdate(data);
                    break;
            }
        });
    }
    
    /**
     * パフォーマンス監視の開始
     * @private
     */
    _startPerformanceMonitoring() {
        if (typeof window === 'undefined') return;
        
        // Performance Observer APIの使用
        if ('PerformanceObserver' in window) {
            const observer = new PerformanceObserver((list) => {
                const entries = list.getEntries();
                entries.forEach(entry => {
                    if (entry.name.includes('seo-image-optimization')) {
                        this._trackImageOptimizationPerformance(entry);
                    }
                });
            });
            
            observer.observe({ entryTypes: ['measure'] });
        }
        
        // 定期的なメトリクス報告
        setInterval(() => {
            this._reportPerformanceMetrics();
        }, 60000); // 1分ごと
    }
    
    /**
     * パフォーマンスメトリクスの報告
     * @private
     */
    _reportPerformanceMetrics() {
        const metrics = this.getPerformanceMetrics();
        seoLogger.performance('SEO performance metrics', 0, metrics);
    }
    
    /**
     * パフォーマンスメトリクスの取得
     * @returns {Object}
     */
    getPerformanceMetrics() {
        const cacheEfficiency = this.performanceMetrics.cacheHits / 
            (this.performanceMetrics.cacheHits + this.performanceMetrics.cacheMisses) || 0;
        
        return {
            ...this.performanceMetrics,
            cacheEfficiency: Math.round(cacheEfficiency * 100),
            averageProcessingTime: this.performanceMetrics.imageOptimizations > 0 ?
                Math.round(this.performanceMetrics.totalProcessingTime / this.performanceMetrics.imageOptimizations) : 0,
            totalCacheSize: this.imageCache.size + this.metadataCache.size,
            webpSupported: this.webpSupported
        };
    }
    
    /**
     * キャッシュのクリア
     * @param {string} type - クリアするキャッシュタイプ
     */
    clearCache(type = 'all') {
        switch (type) {
            case 'images':
                this.imageCache.clear();
                break;
            case 'metadata':
                this.metadataCache.clear();
                break;
            case 'compression':
                this.compressionCache.clear();
                break;
            case 'all':
            default:
                this.imageCache.clear();
                this.metadataCache.clear();
                this.compressionCache.clear();
                break;
        }
        
        seoLogger.info(`SEO cache cleared: ${type}`);
    }
    
    /**
     * 画像最適化パフォーマンスの追跡
     * @private
     */
    _trackImageOptimizationPerformance(entry) {
        const duration = entry.duration;
        this.performanceMetrics.totalProcessingTime += duration;
        
        seoLogger.performance(`Image optimization took ${duration.toFixed(2)}ms`, duration);
    }
    
    /**
     * 画像最適化結果の処理
     * @private
     */
    _handleImageOptimizationResult(data) {
        const { imageUrl, optimizedUrl, compressionRatio } = data;
        
        // 圧縮率の更新
        if (compressionRatio) {
            const currentRatio = this.performanceMetrics.averageCompressionRatio;
            const count = this.performanceMetrics.imageOptimizations;
            this.performanceMetrics.averageCompressionRatio = 
                (currentRatio * count + compressionRatio) / (count + 1);
        }
        
        seoLogger.info(`Image optimization completed: ${imageUrl} -> ${optimizedUrl}`);
    }
    
    /**
     * キャッシュ更新の処理
     * @private
     */
    _handleCacheUpdate(data) {
        const { type, key, size } = data;
        seoLogger.info(`Cache updated: ${type} (${key}) - ${size} bytes`);
    }
    
    /**
     * リソースのクリーンアップ
     */
    cleanup() {
        this.clearCache();
        this.loadingTasks.clear();
        
        seoLogger.info('SEOPerformanceOptimizer cleaned up');
    }
}
