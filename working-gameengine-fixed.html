<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>ä¿®æ­£ç‰ˆå‹•ä½œã™ã‚‹GameEngine - Issue #113</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: #f0f0f0;
        }
        
        #gameContainer {
            text-align: center;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        #gameCanvas {
            border: 2px solid #333;
            background: #e8f4f8;
        }
        
        button {
            margin: 5px;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background: #007bff;
            color: white;
        }
        
        button:hover { background: #0056b3; }
        button:disabled { background: #6c757d; cursor: not-allowed; }
        
        #status {
            margin: 15px 0;
            padding: 10px;
            border-radius: 5px;
            font-weight: bold;
        }
        .status-success { background: #d4edda; color: #155724; }
        .status-warning { background: #fff3cd; color: #856404; }
        .status-error { background: #f8d7da; color: #721c24; }
        .status-info { background: #cce5f0; color: #0c5460; }
        
        #log {
            margin-top: 20px;
            text-align: left;
            background: #f8f8f8;
            padding: 10px;
            border-radius: 5px;
            max-height: 350px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
        }
        
        .log-info { color: #0066cc; }
        .log-error { color: #cc0000; font-weight: bold; }
        .log-success { color: #006600; }
        .log-warning { color: #cc6600; }
    </style>
</head>
<body>
    <div id="gameContainer">
        <h1>ğŸ® ä¿®æ­£ç‰ˆå‹•ä½œã™ã‚‹GameEngine</h1>
        <p>ã‚¨ãƒ©ãƒ¼ä¿®æ­£ã¨å®‰å…¨ãªåˆæœŸåŒ–ã§ã‚²ãƒ¼ãƒ ã‚’å‹•ã‹ã—ã¾ã™</p>
        
        <div id="status" class="status-info">å¾…æ©Ÿä¸­ - GameEngineä½œæˆãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„</div>
        
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <div>
            <button id="createBtn" onclick="createFixedGameEngine()">ğŸš€ ä¿®æ­£ç‰ˆGameEngineä½œæˆ</button>
            <button id="spawnBtn" onclick="testBubbleSpawn()" disabled>ğŸˆ ãƒãƒ–ãƒ«ç”Ÿæˆãƒ†ã‚¹ãƒˆ</button>
            <button id="startBtn" onclick="startGame()" disabled>â–¶ï¸ ã‚²ãƒ¼ãƒ é–‹å§‹</button>
            <button id="stopBtn" onclick="stopGame()" disabled>â¹ï¸ ã‚²ãƒ¼ãƒ åœæ­¢</button>
            <button onclick="clearLog()">ğŸ—‘ï¸ ãƒ­ã‚°ã‚¯ãƒªã‚¢</button>
        </div>
        
        <div id="log"></div>
    </div>

    <script type="module">
        let fixedGameEngine = null;
        let gameMode = 'unknown'; // 'real', 'minimal', 'failed'
        
        // ===== ãƒ­ã‚°æ©Ÿèƒ½ =====
        function log(message, type = 'info') {
            const logElement = document.getElementById('log');
            const div = document.createElement('div');
            div.className = `log-${type}`;
            div.innerHTML = `<strong>[${new Date().toLocaleTimeString()}]</strong> ${message}`;
            logElement.appendChild(div);
            logElement.scrollTop = logElement.scrollHeight;
            console.log(`[${type.toUpperCase()}] ${message}`);
        }
        
        function updateStatus(message, type = 'info') {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = `status-${type}`;
        }
        
        function enableButtons(buttons) {
            buttons.forEach(id => {
                const btn = document.getElementById(id);
                if (btn) btn.disabled = false;
            });
        }
        
        window.clearLog = function() {
            document.getElementById('log').innerHTML = '';
        };
        
        // ===== ã‚¨ãƒ©ãƒ¼ä¿®æ­£ã®ãŸã‚ã®ãƒ‘ãƒƒãƒé–¢æ•° =====
        async function applyErrorFixPatches() {
            log('ã‚¨ãƒ©ãƒ¼ä¿®æ­£ãƒ‘ãƒƒãƒã‚’é©ç”¨ä¸­...', 'info');
            
            try {
                // ErrorHandlerã«ä¸è¶³ã—ã¦ã„ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è¿½åŠ 
                const { getErrorHandler } = await import('./src/utils/ErrorHandler.js');
                const errorHandler = getErrorHandler();
                
                if (errorHandler && !errorHandler.setRetryHandler) {
                    errorHandler.setRetryHandler = function(handler) {
                        log('âš ï¸ ErrorHandler.setRetryHandler ãƒ‘ãƒƒãƒé©ç”¨', 'warning');
                        this._retryHandler = handler;
                        return this;
                    };
                    log('âœ… ErrorHandler.setRetryHandler ãƒ‘ãƒƒãƒå®Œäº†', 'success');
                }
                
                // ConfigurationManagerã®è¨­å®šå€¤ã‚¨ãƒ©ãƒ¼ã‚’ä¿®æ­£
                const { getConfigurationManager } = await import('./src/core/ConfigurationManager.js');
                const configManager = getConfigurationManager();
                
                if (configManager) {
                    // å•é¡Œã®ã‚ã‚‹è¨­å®šå€¤ã‚’ä¿®æ­£
                    try {
                        // effects.quality.autoAdjustã‚’booleanã«ä¿®æ­£
                        configManager.set('effects', 'quality.autoAdjust', true);
                        
                        // effects.particles.qualityã‚’é©åˆ‡ãªæ–‡å­—åˆ—ã«ä¿®æ­£
                        configManager.set('effects', 'particles.quality', 'medium');
                        
                        // ç„¡åŠ¹ãªã‚­ãƒ¼ã‚’å‰Šé™¤/ä¿®æ­£
                        configManager.set('effects', 'audio.timingCompensation', 0);
                        configManager.set('effects', 'seasonal.autoDetection', true);
                        configManager.set('effects', 'seasonal.events', true);
                        
                        log('âœ… ConfigurationManagerè¨­å®šå€¤ãƒ‘ãƒƒãƒå®Œäº†', 'success');
                    } catch (configError) {
                        log(`âš ï¸ ConfigurationManager ãƒ‘ãƒƒãƒä¸­ã«ã‚¨ãƒ©ãƒ¼: ${configError.message}`, 'warning');
                    }
                }
                
                return true;
            } catch (patchError) {
                log(`âŒ ãƒ‘ãƒƒãƒé©ç”¨ã‚¨ãƒ©ãƒ¼: ${patchError.message}`, 'error');
                return false;
            }
        }
        
        // ===== ä¿®æ­£ç‰ˆGameEngineãƒ©ãƒƒãƒ‘ãƒ¼ =====
        class FixedGameEngine {
            constructor(canvas) {
                this.canvas = canvas;
                this.context = canvas.getContext('2d');
                this.isRunning = false;
                this.bubbles = [];
                this.score = 0;
                this.frameCount = 0;
                
                // å®Ÿéš›ã®GameEngineã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
                this.realGameEngine = null;
                this.useRealEngine = false;
                
                // ã‚¨ãƒ©ãƒ¼ç„¡åŠ¹åŒ–ãƒ•ãƒ©ã‚°
                this.suppressErrors = true;
                
                log('FixedGameEngine åˆæœŸåŒ–å®Œäº†', 'success');
            }
            
            // å®Ÿéš›ã®GameEngineã‚’å®‰å…¨ã«çµ±åˆï¼ˆã‚¨ãƒ©ãƒ¼ä¿®æ­£ãƒ‘ãƒƒãƒä»˜ãï¼‰
            async integrateRealGameEngineWithFixes() {
                log('=== ä¿®æ­£ç‰ˆGameEngineçµ±åˆé–‹å§‹ ===', 'info');
                
                try {
                    // Step 1: ã‚¨ãƒ©ãƒ¼ä¿®æ­£ãƒ‘ãƒƒãƒã‚’é©ç”¨
                    updateStatus('ã‚¨ãƒ©ãƒ¼ä¿®æ­£ãƒ‘ãƒƒãƒã‚’é©ç”¨ä¸­...', 'info');
                    const patchSuccess = await applyErrorFixPatches();
                    
                    if (!patchSuccess) {
                        log('âš ï¸ ãƒ‘ãƒƒãƒé©ç”¨ã«å¤±æ•—ã—ã¾ã—ãŸãŒç¶šè¡Œã—ã¾ã™', 'warning');
                    }
                    
                    // Step 2: ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒ©ãƒ¼è¨­å®š
                    const originalConsoleError = console.error;
                    const capturedErrors = [];
                    
                    console.error = function(...args) {
                        const errorMsg = args.join(' ');
                        capturedErrors.push(errorMsg);
                        
                        // æ—¢çŸ¥ã®ã‚¨ãƒ©ãƒ¼ã‚’ç„¡è¦–
                        if (errorMsg.includes('setRetryHandler is not a function') ||
                            errorMsg.includes('ConfigurationManager') ||
                            errorMsg.includes('å‹ãŒä¸æ­£')) {
                            log(`âš ï¸ æ—¢çŸ¥ã®ã‚¨ãƒ©ãƒ¼ï¼ˆç„¡è¦–ï¼‰: ${errorMsg}`, 'warning');
                            return;
                        }
                        
                        originalConsoleError.apply(console, args);
                    };
                    
                    // Step 3: GameEngineä½œæˆ
                    updateStatus('GameEngineã‚’å®‰å…¨ã«ä½œæˆä¸­...', 'info');
                    
                    log('GameEngineã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚’é–‹å§‹...', 'info');
                    console.log('EARLY_DEBUG: GameEngineã‚¤ãƒ³ãƒãƒ¼ãƒˆé–‹å§‹');
                    const { GameEngine } = await import('./src/core/GameEngine.js');
                    log('âœ… GameEngineã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆæˆåŠŸ', 'success');
                    console.log('EARLY_DEBUG: GameEngineã‚¤ãƒ³ãƒãƒ¼ãƒˆæˆåŠŸ');
                    
                    try {
                        log('GameEngineã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼å‘¼ã³å‡ºã—é–‹å§‹...', 'info');
                        console.log('EARLY_DEBUG: GameEngineã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼å‘¼ã³å‡ºã—é–‹å§‹');
                        this.realGameEngine = new GameEngine(this.canvas);
                        log('âœ… å®Ÿéš›ã®GameEngineä½œæˆæˆåŠŸ', 'success');
                        console.log('EARLY_DEBUG: GameEngineã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼å®Œäº†');
                        
                        // ä¸»è¦ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆãƒã‚§ãƒƒã‚¯
                        await this.checkAndFixComponents();
                        
                        this.useRealEngine = true;
                        updateStatus('å®Ÿéš›ã®GameEngineçµ±åˆå®Œäº†', 'success');
                        
                        return true;
                        
                    } catch (gameEngineError) {
                        log(`âš ï¸ GameEngineä½œæˆã‚¨ãƒ©ãƒ¼: ${gameEngineError.message}`, 'warning');
                        
                        // ã‚­ãƒ£ãƒƒãƒã—ãŸã‚¨ãƒ©ãƒ¼ã®è©³ç´°è¡¨ç¤º
                        if (capturedErrors.length > 0) {
                            log('ã‚­ãƒ£ãƒƒãƒã—ãŸæ—¢çŸ¥ã‚¨ãƒ©ãƒ¼:', 'info');
                            capturedErrors.forEach((error, i) => {
                                log(`  ${i+1}. ${error}`, 'warning');
                            });
                        }
                        
                        log('æœ€å°ç‰ˆãƒ¢ãƒ¼ãƒ‰ã§ç¶šè¡Œã—ã¾ã™', 'info');
                        updateStatus('æœ€å°ç‰ˆGameEngineã§å‹•ä½œ', 'warning');
                        return false;
                    } finally {
                        console.error = originalConsoleError;
                    }
                    
                } catch (integrationError) {
                    log(`âŒ çµ±åˆãƒ—ãƒ­ã‚»ã‚¹ã‚¨ãƒ©ãƒ¼: ${integrationError.message}`, 'error');
                    updateStatus('çµ±åˆå¤±æ•— - æœ€å°ç‰ˆã§å‹•ä½œ', 'error');
                    return false;
                }
            }
            
            async checkAndFixComponents() {
                log('=== GameEngineã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆç¢ºèªãƒ»ä¿®æ­£ ===', 'info');
                
                const components = [
                    { name: 'canvas', obj: this.realGameEngine.canvas },
                    { name: 'context', obj: this.realGameEngine.context },
                    { name: 'bubbleManager', obj: this.realGameEngine.bubbleManager },
                    { name: 'stageManager', obj: this.realGameEngine.stageManager },
                    { name: 'sceneManager', obj: this.realGameEngine.sceneManager },
                    { name: 'scoreManager', obj: this.realGameEngine.scoreManager },
                    { name: 'playerData', obj: this.realGameEngine.playerData },
                    { name: 'configManager', obj: this.realGameEngine.configManager }
                ];
                
                let workingComponents = 0;
                
                components.forEach(comp => {
                    if (comp.obj) {
                        log(`âœ… ${comp.name}: OK`, 'success');
                        workingComponents++;
                    } else {
                        log(`âŒ ${comp.name}: NULL/UNDEFINED`, 'error');
                    }
                });
                
                log(`å‹•ä½œã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ: ${workingComponents}/${components.length}`, 'info');
                
                // æœ€å°è¦ä»¶ã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆbubbleManagerãŒé‡è¦ï¼‰
                if (this.realGameEngine.bubbleManager) {
                    log('âœ… ãƒãƒ–ãƒ«ç”Ÿæˆã‚·ã‚¹ãƒ†ãƒ åˆ©ç”¨å¯èƒ½', 'success');
                    return true;
                } else {
                    log('âš ï¸ ãƒãƒ–ãƒ«ç”Ÿæˆã‚·ã‚¹ãƒ†ãƒ ä¸å¯ - æœ€å°ç‰ˆã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯', 'warning');
                    this.useRealEngine = false;
                    return false;
                }
            }
            
            // ãƒãƒ–ãƒ«ç”Ÿæˆï¼ˆå®Ÿéš›ã®ã‚¨ãƒ³ã‚¸ãƒ³ã¾ãŸã¯æœ€å°ç‰ˆï¼‰
            spawnBubble() {
                console.log('[DEBUG] FixedGameEngine.spawnBubbleé–‹å§‹');
                console.log('[DEBUG] useRealEngine:', this.useRealEngine);
                console.log('[DEBUG] realGameEngine:', !!this.realGameEngine);
                console.log('[DEBUG] bubbleManager:', !!(this.realGameEngine && this.realGameEngine.bubbleManager));
                
                if (this.useRealEngine && this.realGameEngine && this.realGameEngine.bubbleManager) {
                    try {
                        log('å®Ÿéš›ã®GameEngineã§ãƒãƒ–ãƒ«ç”Ÿæˆã‚’è©¦è¡Œä¸­...', 'info');
                        console.log('[DEBUG] realGameEngine.bubbleManager.spawnBubbleå‘¼ã³å‡ºã—');
                        
                        const bubble = this.realGameEngine.bubbleManager.spawnBubble('normal');
                        console.log('[DEBUG] spawnBubbleçµæœ:', bubble);
                        console.log('[DEBUG] bubble type:', typeof bubble);
                        console.log('[DEBUG] bubble keys:', bubble ? Object.keys(bubble) : 'null');
                        
                        if (bubble) {
                            log(`âœ… å®Ÿéš›ã®GameEngineã§ãƒãƒ–ãƒ«ç”ŸæˆæˆåŠŸ ID:${bubble.id || 'undefined'}`, 'success');
                            return bubble;
                        } else {
                            log('âš ï¸ å®Ÿéš›ã®ã‚¨ãƒ³ã‚¸ãƒ³ã§ãƒãƒ–ãƒ«ç”Ÿæˆå¤±æ•—ï¼ˆnullè¿”å´ï¼‰', 'warning');
                            log('æœ€å°ç‰ˆã‚¨ãƒ³ã‚¸ãƒ³ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯', 'info');
                        }
                    } catch (error) {
                        log(`âš ï¸ å®Ÿéš›ã®ã‚¨ãƒ³ã‚¸ãƒ³ã§ãƒãƒ–ãƒ«ç”Ÿæˆã‚¨ãƒ©ãƒ¼: ${error.message}`, 'warning');
                        log(`ã‚¨ãƒ©ãƒ¼ã‚¹ã‚¿ãƒƒã‚¯: ${error.stack}`, 'warning');
                        this.useRealEngine = false;
                    }
                }
                
                // æœ€å°ç‰ˆãƒãƒ–ãƒ«ç”Ÿæˆ
                const bubble = this.createMinimalBubble();
                this.bubbles.push(bubble);
                log(`æœ€å°ç‰ˆã§ãƒãƒ–ãƒ«ç”Ÿæˆ: ID${bubble.id} (${Math.round(bubble.x)}, ${Math.round(bubble.y)})`, 'success');
                return bubble;
            }
            
            createMinimalBubble() {
                const id = 'bubble_' + Date.now() + '_' + Math.floor(Math.random() * 1000);
                const bubble = {
                    id: id,
                    x: 100 + Math.random() * (this.canvas.width - 200),
                    y: 100 + Math.random() * (this.canvas.height - 200),
                    radius: 20 + Math.random() * 25,
                    color: `hsl(${Math.random() * 360}, 70%, 60%)`,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4,
                    life: 1.0
                };
                console.log('[DEBUG] æœ€å°ç‰ˆãƒãƒ–ãƒ«ä½œæˆ:', bubble);
                return bubble;
            }
            
            // ã‚²ãƒ¼ãƒ é–‹å§‹
            start() {
                if (this.useRealEngine && this.realGameEngine && typeof this.realGameEngine.start === 'function') {
                    try {
                        this.realGameEngine.start();
                        log('âœ… å®Ÿéš›ã®GameEngineã§ã‚²ãƒ¼ãƒ é–‹å§‹', 'success');
                        updateStatus('å®Ÿéš›ã®GameEngineã§ã‚²ãƒ¼ãƒ å‹•ä½œä¸­', 'success');
                        return;
                    } catch (error) {
                        log(`âš ï¸ å®Ÿéš›ã®ã‚¨ãƒ³ã‚¸ãƒ³ã§ã‚²ãƒ¼ãƒ é–‹å§‹å¤±æ•—: ${error.message}`, 'warning');
                        this.useRealEngine = false;
                    }
                }
                
                // æœ€å°ç‰ˆã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—
                if (this.isRunning) {
                    log('æ—¢ã«ã‚²ãƒ¼ãƒ å®Ÿè¡Œä¸­', 'info');
                    return;
                }
                
                this.isRunning = true;
                
                // åˆæœŸãƒãƒ–ãƒ«ç”Ÿæˆ
                for (let i = 0; i < 3; i++) {
                    this.spawnBubble();
                }
                
                this.gameLoop();
                log('âœ… æœ€å°ç‰ˆã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—é–‹å§‹', 'success');
                updateStatus('æœ€å°ç‰ˆGameEngineã§ã‚²ãƒ¼ãƒ å‹•ä½œä¸­', 'success');
            }
            
            stop() {
                if (this.useRealEngine && this.realGameEngine && typeof this.realGameEngine.stop === 'function') {
                    try {
                        this.realGameEngine.stop();
                        log('å®Ÿéš›ã®GameEngineã§ã‚²ãƒ¼ãƒ åœæ­¢', 'info');
                        updateStatus('ã‚²ãƒ¼ãƒ åœæ­¢', 'info');
                        return;
                    } catch (error) {
                        log(`å®Ÿéš›ã®ã‚¨ãƒ³ã‚¸ãƒ³ã§ã‚²ãƒ¼ãƒ åœæ­¢å¤±æ•—: ${error.message}`, 'warning');
                    }
                }
                
                this.isRunning = false;
                log('æœ€å°ç‰ˆã‚²ãƒ¼ãƒ åœæ­¢', 'info');
                updateStatus('ã‚²ãƒ¼ãƒ åœæ­¢', 'info');
            }
            
            gameLoop() {
                if (!this.isRunning) return;
                
                this.update();
                this.render();
                
                this.frameCount++;
                
                // è‡ªå‹•ãƒãƒ–ãƒ«ç”Ÿæˆï¼ˆ4ç§’ã«1å›ç¨‹åº¦ï¼‰
                if (this.frameCount % 240 === 0) {
                    this.spawnBubble();
                }
                
                requestAnimationFrame(() => this.gameLoop());
            }
            
            update() {
                this.bubbles = this.bubbles.filter(bubble => {
                    // ç‰©ç†æ›´æ–°
                    bubble.x += bubble.vx;
                    bubble.y += bubble.vy;
                    
                    // ç”»é¢ç«¯åå°„
                    if (bubble.x - bubble.radius < 0 || bubble.x + bubble.radius > this.canvas.width) {
                        bubble.vx *= -0.8;
                        bubble.x = Math.max(bubble.radius, Math.min(this.canvas.width - bubble.radius, bubble.x));
                    }
                    if (bubble.y - bubble.radius < 0 || bubble.y + bubble.radius > this.canvas.height) {
                        bubble.vy *= -0.8;
                        bubble.y = Math.max(bubble.radius, Math.min(this.canvas.height - bubble.radius, bubble.y));
                    }
                    
                    // å¯¿å‘½æ¸›å°‘
                    bubble.life -= 0.002;
                    return bubble.life > 0;
                });
            }
            
            render() {
                const ctx = this.context;
                
                // èƒŒæ™¯ã‚¯ãƒªã‚¢
                ctx.fillStyle = '#e8f4f8';
                ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // ãƒãƒ–ãƒ«æç”»
                this.bubbles.forEach(bubble => {
                    ctx.save();
                    ctx.globalAlpha = bubble.life;
                    
                    // ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
                    const gradient = ctx.createRadialGradient(
                        bubble.x - bubble.radius/3, bubble.y - bubble.radius/3, 0,
                        bubble.x, bubble.y, bubble.radius
                    );
                    gradient.addColorStop(0, bubble.color);
                    gradient.addColorStop(1, this.darkenColor(bubble.color));
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(bubble.x, bubble.y, bubble.radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // ãƒã‚¤ãƒ©ã‚¤ãƒˆ
                    ctx.fillStyle = 'rgba(255,255,255,0.7)';
                    ctx.beginPath();
                    ctx.arc(bubble.x - bubble.radius/3, bubble.y - bubble.radius/3, bubble.radius/4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                });
                
                // UIæƒ…å ±
                ctx.fillStyle = '#333';
                ctx.font = '16px Arial';
                ctx.fillText(`ã‚¹ã‚³ã‚¢: ${this.score}`, 10, 30);
                ctx.fillText(`ãƒãƒ–ãƒ«æ•°: ${this.bubbles.length}`, 10, 55);
                ctx.fillText(`ã‚¨ãƒ³ã‚¸ãƒ³: ${this.useRealEngine ? 'å®Ÿéš›ã®GameEngine' : 'æœ€å°ç‰ˆã‚¨ãƒ³ã‚¸ãƒ³'}`, 10, 80);
                ctx.fillText(`ãƒ•ãƒ¬ãƒ¼ãƒ : ${this.frameCount}`, 10, 105);
            }
            
            darkenColor(color) {
                // HSLè‰²ç›¸ã‹ã‚‰æš—ã„è‰²ã‚’ç”Ÿæˆ
                const hsl = color.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
                if (hsl) {
                    return `hsl(${hsl[1]}, ${hsl[2]}%, ${Math.max(20, parseInt(hsl[3]) - 20)}%)`;
                }
                return color;
            }
            
            handleClick(x, y) {
                let hit = false;
                
                for (let i = this.bubbles.length - 1; i >= 0; i--) {
                    const bubble = this.bubbles[i];
                    const dx = x - bubble.x;
                    const dy = y - bubble.y;
                    
                    if (dx * dx + dy * dy <= bubble.radius * bubble.radius) {
                        this.bubbles.splice(i, 1);
                        this.score += 10;
                        hit = true;
                        log(`ãƒãƒ–ãƒ«ç ´å£Š! ã‚¹ã‚³ã‚¢+10 (åˆè¨ˆ: ${this.score})`, 'success');
                        
                        // ç°¡å˜ãªãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«åŠ¹æœ
                        this.createPopEffect(bubble.x, bubble.y, bubble.color);
                        break;
                    }
                }
                
                if (!hit) {
                    log('ç©ºæŒ¯ã‚Š', 'info');
                }
                
                return hit;
            }
            
            createPopEffect(x, y, color) {
                // ç°¡æ˜“ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«åŠ¹æœ
                for (let i = 0; i < 6; i++) {
                    setTimeout(() => {
                        const ctx = this.context;
                        ctx.save();
                        ctx.fillStyle = color;
                        ctx.globalAlpha = 0.7;
                        ctx.beginPath();
                        ctx.arc(
                            x + (Math.random() - 0.5) * 40, 
                            y + (Math.random() - 0.5) * 40, 
                            3, 0, Math.PI * 2
                        );
                        ctx.fill();
                        ctx.restore();
                    }, i * 50);
                }
            }
        }
        
        // ===== ãƒœã‚¿ãƒ³ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ =====
        window.createFixedGameEngine = async function() {
            updateStatus('ä¿®æ­£ç‰ˆGameEngineä½œæˆä¸­...', 'info');
            document.getElementById('createBtn').disabled = true;
            
            log('=== ä¿®æ­£ç‰ˆGameEngineä½œæˆé–‹å§‹ ===', 'info');
            
            const canvas = document.getElementById('gameCanvas');
            fixedGameEngine = new FixedGameEngine(canvas);
            
            // å®Ÿéš›ã®GameEngineçµ±åˆã‚’è©¦è¡Œï¼ˆã‚¨ãƒ©ãƒ¼ä¿®æ­£ä»˜ãï¼‰
            const success = await fixedGameEngine.integrateRealGameEngineWithFixes();
            
            if (success) {
                log('ğŸ‰ å®Ÿéš›ã®GameEngineãŒæ­£å¸¸ã«çµ±åˆã•ã‚Œã¾ã—ãŸ', 'success');
                gameMode = 'real';
            } else {
                log('ğŸ”§ æœ€å°ç‰ˆGameEngineã§å‹•ä½œã—ã¾ã™', 'warning');
                gameMode = 'minimal';
            }
            
            // ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆè¨­å®š
            canvas.addEventListener('click', (event) => {
                if (!fixedGameEngine) return;
                
                const rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                
                fixedGameEngine.handleClick(x, y);
            });
            
            // ãƒœã‚¿ãƒ³ã‚’æœ‰åŠ¹åŒ–
            enableButtons(['spawnBtn', 'startBtn']);
            log('âœ… ä¿®æ­£ç‰ˆGameEngineæº–å‚™å®Œäº† - å„æ©Ÿèƒ½ã‚’ãƒ†ã‚¹ãƒˆã—ã¦ãã ã•ã„', 'success');
        };
        
        window.testBubbleSpawn = function() {
            if (!fixedGameEngine) {
                log('âŒ ã¾ãšä¿®æ­£ç‰ˆGameEngineã‚’ä½œæˆã—ã¦ãã ã•ã„', 'error');
                return;
            }
            
            log('ãƒãƒ–ãƒ«ç”Ÿæˆãƒ†ã‚¹ãƒˆå®Ÿè¡Œä¸­...', 'info');
            const bubble = fixedGameEngine.spawnBubble();
            
            if (bubble) {
                log(`âœ… ãƒãƒ–ãƒ«ç”Ÿæˆãƒ†ã‚¹ãƒˆæˆåŠŸ: ID ${bubble.id}`, 'success');
                updateStatus(`ãƒãƒ–ãƒ«ç”ŸæˆæˆåŠŸ (${gameMode}ç‰ˆ)`, 'success');
            } else {
                log('âŒ ãƒãƒ–ãƒ«ç”Ÿæˆãƒ†ã‚¹ãƒˆå¤±æ•—', 'error');
                updateStatus('ãƒãƒ–ãƒ«ç”Ÿæˆå¤±æ•—', 'error');
            }
        };
        
        window.startGame = function() {
            if (!fixedGameEngine) {
                log('âŒ ã¾ãšä¿®æ­£ç‰ˆGameEngineã‚’ä½œæˆã—ã¦ãã ã•ã„', 'error');
                return;
            }
            
            fixedGameEngine.start();
            enableButtons(['stopBtn']);
            document.getElementById('startBtn').disabled = true;
        };
        
        window.stopGame = function() {
            if (!fixedGameEngine) {
                log('âŒ ã‚²ãƒ¼ãƒ ãŒä½œæˆã•ã‚Œã¦ã„ã¾ã›ã‚“', 'error');
                return;
            }
            
            fixedGameEngine.stop();
            enableButtons(['startBtn']);
            document.getElementById('stopBtn').disabled = true;
        };
        
        // ===== åˆæœŸåŒ– =====
        log('ä¿®æ­£ç‰ˆå‹•ä½œã™ã‚‹GameEngine æº–å‚™å®Œäº†', 'info');
        log('ã‚¨ãƒ©ãƒ¼ä¿®æ­£ãƒ‘ãƒƒãƒã‚’å«ã‚€å®‰å…¨ãªGameEngineå®Ÿè£…', 'info');
        log('1. ã€Œä¿®æ­£ç‰ˆGameEngineä½œæˆã€ã‚’ã‚¯ãƒªãƒƒã‚¯', 'info');
        log('2. ã€Œãƒãƒ–ãƒ«ç”Ÿæˆãƒ†ã‚¹ãƒˆã€ã§å‹•ä½œç¢ºèª', 'info');
        log('3. ã€Œã‚²ãƒ¼ãƒ é–‹å§‹ã€ã§ã‚²ãƒ¼ãƒ é–‹å§‹', 'info');
        log('4. ãƒãƒ–ãƒ«ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦æ¥½ã—ã‚“ã§ãã ã•ã„ï¼', 'info');
    </script>
</body>
</html>