<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>修正版動作するGameEngine - Issue #113</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: #f0f0f0;
        }
        
        #gameContainer {
            text-align: center;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        #gameCanvas {
            border: 2px solid #333;
            background: #e8f4f8;
        }
        
        button {
            margin: 5px;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background: #007bff;
            color: white;
        }
        
        button:hover { background: #0056b3; }
        button:disabled { background: #6c757d; cursor: not-allowed; }
        
        #status {
            margin: 15px 0;
            padding: 10px;
            border-radius: 5px;
            font-weight: bold;
        }
        .status-success { background: #d4edda; color: #155724; }
        .status-warning { background: #fff3cd; color: #856404; }
        .status-error { background: #f8d7da; color: #721c24; }
        .status-info { background: #cce5f0; color: #0c5460; }
        
        #log {
            margin-top: 20px;
            text-align: left;
            background: #f8f8f8;
            padding: 10px;
            border-radius: 5px;
            max-height: 350px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
        }
        
        .log-info { color: #0066cc; }
        .log-error { color: #cc0000; font-weight: bold; }
        .log-success { color: #006600; }
        .log-warning { color: #cc6600; }
    </style>
</head>
<body>
    <div id="gameContainer">
        <h1>🎮 修正版動作するGameEngine</h1>
        <p>エラー修正と安全な初期化でゲームを動かします</p>
        
        <div id="status" class="status-info">待機中 - GameEngine作成ボタンをクリックしてください</div>
        
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <div>
            <button id="createBtn" onclick="createFixedGameEngine()">🚀 修正版GameEngine作成</button>
            <button id="spawnBtn" onclick="testBubbleSpawn()" disabled>🎈 バブル生成テスト</button>
            <button id="startBtn" onclick="startGame()" disabled>▶️ ゲーム開始</button>
            <button id="stopBtn" onclick="stopGame()" disabled>⏹️ ゲーム停止</button>
            <button onclick="clearLog()">🗑️ ログクリア</button>
        </div>
        
        <div id="log"></div>
    </div>

    <script type="module">
        let fixedGameEngine = null;
        let gameMode = 'unknown'; // 'real', 'minimal', 'failed'
        
        // ===== ログ機能 =====
        function log(message, type = 'info') {
            const logElement = document.getElementById('log');
            const div = document.createElement('div');
            div.className = `log-${type}`;
            div.innerHTML = `<strong>[${new Date().toLocaleTimeString()}]</strong> ${message}`;
            logElement.appendChild(div);
            logElement.scrollTop = logElement.scrollHeight;
            console.log(`[${type.toUpperCase()}] ${message}`);
        }
        
        function updateStatus(message, type = 'info') {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = `status-${type}`;
        }
        
        function enableButtons(buttons) {
            buttons.forEach(id => {
                const btn = document.getElementById(id);
                if (btn) btn.disabled = false;
            });
        }
        
        window.clearLog = function() {
            document.getElementById('log').innerHTML = '';
        };
        
        // ===== エラー修正のためのパッチ関数 =====
        async function applyErrorFixPatches() {
            log('エラー修正パッチを適用中...', 'info');
            
            try {
                // ErrorHandlerに不足しているメソッドを追加
                const { getErrorHandler } = await import('./src/utils/ErrorHandler.js');
                const errorHandler = getErrorHandler();
                
                if (errorHandler && !errorHandler.setRetryHandler) {
                    errorHandler.setRetryHandler = function(handler) {
                        log('⚠️ ErrorHandler.setRetryHandler パッチ適用', 'warning');
                        this._retryHandler = handler;
                        return this;
                    };
                    log('✅ ErrorHandler.setRetryHandler パッチ完了', 'success');
                }
                
                // ConfigurationManagerの設定値エラーを修正
                const { getConfigurationManager } = await import('./src/core/ConfigurationManager.js');
                const configManager = getConfigurationManager();
                
                if (configManager) {
                    // 問題のある設定値を修正
                    try {
                        // effects.quality.autoAdjustをbooleanに修正
                        configManager.set('effects', 'quality.autoAdjust', true);
                        
                        // effects.particles.qualityを適切な文字列に修正
                        configManager.set('effects', 'particles.quality', 'medium');
                        
                        // 無効なキーを削除/修正
                        configManager.set('effects', 'audio.timingCompensation', 0);
                        configManager.set('effects', 'seasonal.autoDetection', true);
                        configManager.set('effects', 'seasonal.events', true);
                        
                        log('✅ ConfigurationManager設定値パッチ完了', 'success');
                    } catch (configError) {
                        log(`⚠️ ConfigurationManager パッチ中にエラー: ${configError.message}`, 'warning');
                    }
                }
                
                return true;
            } catch (patchError) {
                log(`❌ パッチ適用エラー: ${patchError.message}`, 'error');
                return false;
            }
        }
        
        // ===== 修正版GameEngineラッパー =====
        class FixedGameEngine {
            constructor(canvas) {
                this.canvas = canvas;
                this.context = canvas.getContext('2d');
                this.isRunning = false;
                this.bubbles = [];
                this.score = 0;
                this.frameCount = 0;
                
                // 実際のGameEngineコンポーネント
                this.realGameEngine = null;
                this.useRealEngine = false;
                
                // エラー無効化フラグ
                this.suppressErrors = true;
                
                log('FixedGameEngine 初期化完了', 'success');
            }
            
            // 実際のGameEngineを安全に統合（エラー修正パッチ付き）
            async integrateRealGameEngineWithFixes() {
                log('=== 修正版GameEngine統合開始 ===', 'info');
                
                try {
                    // Step 1: エラー修正パッチを適用
                    updateStatus('エラー修正パッチを適用中...', 'info');
                    const patchSuccess = await applyErrorFixPatches();
                    
                    if (!patchSuccess) {
                        log('⚠️ パッチ適用に失敗しましたが続行します', 'warning');
                    }
                    
                    // Step 2: グローバルエラーハンドラー設定
                    const originalConsoleError = console.error;
                    const capturedErrors = [];
                    
                    console.error = function(...args) {
                        const errorMsg = args.join(' ');
                        capturedErrors.push(errorMsg);
                        
                        // 既知のエラーを無視
                        if (errorMsg.includes('setRetryHandler is not a function') ||
                            errorMsg.includes('ConfigurationManager') ||
                            errorMsg.includes('型が不正')) {
                            log(`⚠️ 既知のエラー（無視）: ${errorMsg}`, 'warning');
                            return;
                        }
                        
                        originalConsoleError.apply(console, args);
                    };
                    
                    // Step 3: GameEngine作成
                    updateStatus('GameEngineを安全に作成中...', 'info');
                    
                    log('GameEngineクラスのインポートを開始...', 'info');
                    console.log('EARLY_DEBUG: GameEngineインポート開始');
                    const { GameEngine } = await import('./src/core/GameEngine.js');
                    log('✅ GameEngineクラスのインポート成功', 'success');
                    console.log('EARLY_DEBUG: GameEngineインポート成功');
                    
                    try {
                        log('GameEngineコンストラクター呼び出し開始...', 'info');
                        console.log('EARLY_DEBUG: GameEngineコンストラクター呼び出し開始');
                        this.realGameEngine = new GameEngine(this.canvas);
                        log('✅ 実際のGameEngine作成成功', 'success');
                        console.log('EARLY_DEBUG: GameEngineコンストラクター完了');
                        
                        // 主要コンポーネントチェック
                        await this.checkAndFixComponents();
                        
                        this.useRealEngine = true;
                        updateStatus('実際のGameEngine統合完了', 'success');
                        
                        return true;
                        
                    } catch (gameEngineError) {
                        log(`⚠️ GameEngine作成エラー: ${gameEngineError.message}`, 'warning');
                        
                        // キャッチしたエラーの詳細表示
                        if (capturedErrors.length > 0) {
                            log('キャッチした既知エラー:', 'info');
                            capturedErrors.forEach((error, i) => {
                                log(`  ${i+1}. ${error}`, 'warning');
                            });
                        }
                        
                        log('最小版モードで続行します', 'info');
                        updateStatus('最小版GameEngineで動作', 'warning');
                        return false;
                    } finally {
                        console.error = originalConsoleError;
                    }
                    
                } catch (integrationError) {
                    log(`❌ 統合プロセスエラー: ${integrationError.message}`, 'error');
                    updateStatus('統合失敗 - 最小版で動作', 'error');
                    return false;
                }
            }
            
            async checkAndFixComponents() {
                log('=== GameEngineコンポーネント確認・修正 ===', 'info');
                
                const components = [
                    { name: 'canvas', obj: this.realGameEngine.canvas },
                    { name: 'context', obj: this.realGameEngine.context },
                    { name: 'bubbleManager', obj: this.realGameEngine.bubbleManager },
                    { name: 'stageManager', obj: this.realGameEngine.stageManager },
                    { name: 'sceneManager', obj: this.realGameEngine.sceneManager },
                    { name: 'scoreManager', obj: this.realGameEngine.scoreManager },
                    { name: 'playerData', obj: this.realGameEngine.playerData },
                    { name: 'configManager', obj: this.realGameEngine.configManager }
                ];
                
                let workingComponents = 0;
                
                components.forEach(comp => {
                    if (comp.obj) {
                        log(`✅ ${comp.name}: OK`, 'success');
                        workingComponents++;
                    } else {
                        log(`❌ ${comp.name}: NULL/UNDEFINED`, 'error');
                    }
                });
                
                log(`動作コンポーネント: ${workingComponents}/${components.length}`, 'info');
                
                // 最小要件をチェック（bubbleManagerが重要）
                if (this.realGameEngine.bubbleManager) {
                    log('✅ バブル生成システム利用可能', 'success');
                    return true;
                } else {
                    log('⚠️ バブル生成システム不可 - 最小版にフォールバック', 'warning');
                    this.useRealEngine = false;
                    return false;
                }
            }
            
            // バブル生成（実際のエンジンまたは最小版）
            spawnBubble() {
                console.log('[DEBUG] FixedGameEngine.spawnBubble開始');
                console.log('[DEBUG] useRealEngine:', this.useRealEngine);
                console.log('[DEBUG] realGameEngine:', !!this.realGameEngine);
                console.log('[DEBUG] bubbleManager:', !!(this.realGameEngine && this.realGameEngine.bubbleManager));
                
                if (this.useRealEngine && this.realGameEngine && this.realGameEngine.bubbleManager) {
                    try {
                        log('実際のGameEngineでバブル生成を試行中...', 'info');
                        console.log('[DEBUG] realGameEngine.bubbleManager.spawnBubble呼び出し');
                        
                        const bubble = this.realGameEngine.bubbleManager.spawnBubble('normal');
                        console.log('[DEBUG] spawnBubble結果:', bubble);
                        console.log('[DEBUG] bubble type:', typeof bubble);
                        console.log('[DEBUG] bubble keys:', bubble ? Object.keys(bubble) : 'null');
                        
                        if (bubble) {
                            log(`✅ 実際のGameEngineでバブル生成成功 ID:${bubble.id || 'undefined'}`, 'success');
                            return bubble;
                        } else {
                            log('⚠️ 実際のエンジンでバブル生成失敗（null返却）', 'warning');
                            log('最小版エンジンにフォールバック', 'info');
                        }
                    } catch (error) {
                        log(`⚠️ 実際のエンジンでバブル生成エラー: ${error.message}`, 'warning');
                        log(`エラースタック: ${error.stack}`, 'warning');
                        this.useRealEngine = false;
                    }
                }
                
                // 最小版バブル生成
                const bubble = this.createMinimalBubble();
                this.bubbles.push(bubble);
                log(`最小版でバブル生成: ID${bubble.id} (${Math.round(bubble.x)}, ${Math.round(bubble.y)})`, 'success');
                return bubble;
            }
            
            createMinimalBubble() {
                const id = 'bubble_' + Date.now() + '_' + Math.floor(Math.random() * 1000);
                const bubble = {
                    id: id,
                    x: 100 + Math.random() * (this.canvas.width - 200),
                    y: 100 + Math.random() * (this.canvas.height - 200),
                    radius: 20 + Math.random() * 25,
                    color: `hsl(${Math.random() * 360}, 70%, 60%)`,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4,
                    life: 1.0
                };
                console.log('[DEBUG] 最小版バブル作成:', bubble);
                return bubble;
            }
            
            // ゲーム開始
            start() {
                if (this.useRealEngine && this.realGameEngine && typeof this.realGameEngine.start === 'function') {
                    try {
                        this.realGameEngine.start();
                        log('✅ 実際のGameEngineでゲーム開始', 'success');
                        updateStatus('実際のGameEngineでゲーム動作中', 'success');
                        return;
                    } catch (error) {
                        log(`⚠️ 実際のエンジンでゲーム開始失敗: ${error.message}`, 'warning');
                        this.useRealEngine = false;
                    }
                }
                
                // 最小版ゲームループ
                if (this.isRunning) {
                    log('既にゲーム実行中', 'info');
                    return;
                }
                
                this.isRunning = true;
                
                // 初期バブル生成
                for (let i = 0; i < 3; i++) {
                    this.spawnBubble();
                }
                
                this.gameLoop();
                log('✅ 最小版ゲームループ開始', 'success');
                updateStatus('最小版GameEngineでゲーム動作中', 'success');
            }
            
            stop() {
                if (this.useRealEngine && this.realGameEngine && typeof this.realGameEngine.stop === 'function') {
                    try {
                        this.realGameEngine.stop();
                        log('実際のGameEngineでゲーム停止', 'info');
                        updateStatus('ゲーム停止', 'info');
                        return;
                    } catch (error) {
                        log(`実際のエンジンでゲーム停止失敗: ${error.message}`, 'warning');
                    }
                }
                
                this.isRunning = false;
                log('最小版ゲーム停止', 'info');
                updateStatus('ゲーム停止', 'info');
            }
            
            gameLoop() {
                if (!this.isRunning) return;
                
                this.update();
                this.render();
                
                this.frameCount++;
                
                // 自動バブル生成（4秒に1回程度）
                if (this.frameCount % 240 === 0) {
                    this.spawnBubble();
                }
                
                requestAnimationFrame(() => this.gameLoop());
            }
            
            update() {
                this.bubbles = this.bubbles.filter(bubble => {
                    // 物理更新
                    bubble.x += bubble.vx;
                    bubble.y += bubble.vy;
                    
                    // 画面端反射
                    if (bubble.x - bubble.radius < 0 || bubble.x + bubble.radius > this.canvas.width) {
                        bubble.vx *= -0.8;
                        bubble.x = Math.max(bubble.radius, Math.min(this.canvas.width - bubble.radius, bubble.x));
                    }
                    if (bubble.y - bubble.radius < 0 || bubble.y + bubble.radius > this.canvas.height) {
                        bubble.vy *= -0.8;
                        bubble.y = Math.max(bubble.radius, Math.min(this.canvas.height - bubble.radius, bubble.y));
                    }
                    
                    // 寿命減少
                    bubble.life -= 0.002;
                    return bubble.life > 0;
                });
            }
            
            render() {
                const ctx = this.context;
                
                // 背景クリア
                ctx.fillStyle = '#e8f4f8';
                ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // バブル描画
                this.bubbles.forEach(bubble => {
                    ctx.save();
                    ctx.globalAlpha = bubble.life;
                    
                    // グラデーション
                    const gradient = ctx.createRadialGradient(
                        bubble.x - bubble.radius/3, bubble.y - bubble.radius/3, 0,
                        bubble.x, bubble.y, bubble.radius
                    );
                    gradient.addColorStop(0, bubble.color);
                    gradient.addColorStop(1, this.darkenColor(bubble.color));
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(bubble.x, bubble.y, bubble.radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // ハイライト
                    ctx.fillStyle = 'rgba(255,255,255,0.7)';
                    ctx.beginPath();
                    ctx.arc(bubble.x - bubble.radius/3, bubble.y - bubble.radius/3, bubble.radius/4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                });
                
                // UI情報
                ctx.fillStyle = '#333';
                ctx.font = '16px Arial';
                ctx.fillText(`スコア: ${this.score}`, 10, 30);
                ctx.fillText(`バブル数: ${this.bubbles.length}`, 10, 55);
                ctx.fillText(`エンジン: ${this.useRealEngine ? '実際のGameEngine' : '最小版エンジン'}`, 10, 80);
                ctx.fillText(`フレーム: ${this.frameCount}`, 10, 105);
            }
            
            darkenColor(color) {
                // HSL色相から暗い色を生成
                const hsl = color.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
                if (hsl) {
                    return `hsl(${hsl[1]}, ${hsl[2]}%, ${Math.max(20, parseInt(hsl[3]) - 20)}%)`;
                }
                return color;
            }
            
            handleClick(x, y) {
                let hit = false;
                
                for (let i = this.bubbles.length - 1; i >= 0; i--) {
                    const bubble = this.bubbles[i];
                    const dx = x - bubble.x;
                    const dy = y - bubble.y;
                    
                    if (dx * dx + dy * dy <= bubble.radius * bubble.radius) {
                        this.bubbles.splice(i, 1);
                        this.score += 10;
                        hit = true;
                        log(`バブル破壊! スコア+10 (合計: ${this.score})`, 'success');
                        
                        // 簡単なパーティクル効果
                        this.createPopEffect(bubble.x, bubble.y, bubble.color);
                        break;
                    }
                }
                
                if (!hit) {
                    log('空振り', 'info');
                }
                
                return hit;
            }
            
            createPopEffect(x, y, color) {
                // 簡易パーティクル効果
                for (let i = 0; i < 6; i++) {
                    setTimeout(() => {
                        const ctx = this.context;
                        ctx.save();
                        ctx.fillStyle = color;
                        ctx.globalAlpha = 0.7;
                        ctx.beginPath();
                        ctx.arc(
                            x + (Math.random() - 0.5) * 40, 
                            y + (Math.random() - 0.5) * 40, 
                            3, 0, Math.PI * 2
                        );
                        ctx.fill();
                        ctx.restore();
                    }, i * 50);
                }
            }
        }
        
        // ===== ボタンハンドラー =====
        window.createFixedGameEngine = async function() {
            updateStatus('修正版GameEngine作成中...', 'info');
            document.getElementById('createBtn').disabled = true;
            
            log('=== 修正版GameEngine作成開始 ===', 'info');
            
            const canvas = document.getElementById('gameCanvas');
            fixedGameEngine = new FixedGameEngine(canvas);
            
            // 実際のGameEngine統合を試行（エラー修正付き）
            const success = await fixedGameEngine.integrateRealGameEngineWithFixes();
            
            if (success) {
                log('🎉 実際のGameEngineが正常に統合されました', 'success');
                gameMode = 'real';
            } else {
                log('🔧 最小版GameEngineで動作します', 'warning');
                gameMode = 'minimal';
            }
            
            // クリックイベント設定
            canvas.addEventListener('click', (event) => {
                if (!fixedGameEngine) return;
                
                const rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                
                fixedGameEngine.handleClick(x, y);
            });
            
            // ボタンを有効化
            enableButtons(['spawnBtn', 'startBtn']);
            log('✅ 修正版GameEngine準備完了 - 各機能をテストしてください', 'success');
        };
        
        window.testBubbleSpawn = function() {
            if (!fixedGameEngine) {
                log('❌ まず修正版GameEngineを作成してください', 'error');
                return;
            }
            
            log('バブル生成テスト実行中...', 'info');
            const bubble = fixedGameEngine.spawnBubble();
            
            if (bubble) {
                log(`✅ バブル生成テスト成功: ID ${bubble.id}`, 'success');
                updateStatus(`バブル生成成功 (${gameMode}版)`, 'success');
            } else {
                log('❌ バブル生成テスト失敗', 'error');
                updateStatus('バブル生成失敗', 'error');
            }
        };
        
        window.startGame = function() {
            if (!fixedGameEngine) {
                log('❌ まず修正版GameEngineを作成してください', 'error');
                return;
            }
            
            fixedGameEngine.start();
            enableButtons(['stopBtn']);
            document.getElementById('startBtn').disabled = true;
        };
        
        window.stopGame = function() {
            if (!fixedGameEngine) {
                log('❌ ゲームが作成されていません', 'error');
                return;
            }
            
            fixedGameEngine.stop();
            enableButtons(['startBtn']);
            document.getElementById('stopBtn').disabled = true;
        };
        
        // ===== 初期化 =====
        log('修正版動作するGameEngine 準備完了', 'info');
        log('エラー修正パッチを含む安全なGameEngine実装', 'info');
        log('1. 「修正版GameEngine作成」をクリック', 'info');
        log('2. 「バブル生成テスト」で動作確認', 'info');
        log('3. 「ゲーム開始」でゲーム開始', 'info');
        log('4. バブルをクリックして楽しんでください！', 'info');
    </script>
</body>
</html>